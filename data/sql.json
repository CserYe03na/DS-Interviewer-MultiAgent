[
  {
    "vector_content": "Table: Product\nTable: Sales\nproduct_id is a foreign key to Product table.\nWrite an SQL query that reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\nThe query result format is in the following example:\nProduct table:\nSales table:\nResult table:\nThe product with id 1 was only sold in spring 2019 while the other two were sold after.\nSolution\nselect distinct a.product_id, product_name from sales a join product b on a.product_id = b.product_id where a.product_id\nin\n(select product_id from sales where sale_date >= '2019-01-01' and sale_date <= '2019-03-31')\nand\na.product_id not in\n(select product_id from sales where sale_date > '2019-03-31' or sale_date < '2019-01-01')",
    "metadata": {
      "id": "SQL_1",
      "title": "Sales Analysis 3",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_subquery",
        "sql_date_processing",
        "sql_distinct"
      ],
      "solution_summary": "The query joins the Sales and Product tables to identify products sold within the specified date range of spring 2019. It uses a subquery to filter products that were sold only during this period and excludes those sold outside of it. This approach ensures that only products exclusively sold in spring 2019 are reported.",
      "url": "https://leetcode.com/problems/sales-analysis-3/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Sales%20Analysis%203.sql"
    }
  },
  {
    "vector_content": "Table: Product\nTable: Sales\nproduct_id is a foreign key to Product table.\nWrite an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table.\nThe query result format is in the following example:\nProduct table:\nSales table:\nResult table:\nThe buyer with id 1 bought an S8 but didn't buy an iPhone. The buyer with id 3 bought both.\nSolution\nSelect distinct a.buyer_id\nfrom sales a join\nproduct b\non a.product_id = b.product_id\nwhere a.buyer_id in\n(Select a.buyer_id from sales a join product b on a.product_id = b.product_id where b.product_name = 'S8')\nand\na.buyer_id not in (Select a.buyer_id from sales a join product b on a.product_id = b.product_id where b.product_name = 'iPhone')",
    "metadata": {
      "id": "SQL_2",
      "title": "Sales Analysis 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_subquery",
        "sql_distinct"
      ],
      "solution_summary": "The query selects distinct buyer IDs from the Sales table who have purchased the product 'S8' while ensuring they have not purchased 'iPhone'. It uses subqueries to filter buyers based on their purchases of these specific products, leveraging joins to connect the Sales and Product tables. This approach efficiently isolates the desired buyers by combining inclusion and exclusion criteria.",
      "url": "https://leetcode.com/problems/sales-analysis-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Sales%20Analysis%202.sql"
    }
  },
  {
    "vector_content": "Table: Ads\nA company is running Ads and wants to calculate the performance of each Ad.\nPerformance of the Ad is measured using Click-Through Rate (CTR) where:\nWrite an SQL query to find the ctr of each Ad.\nThe query result format is in the following example:\nAds table:\nResult table:\nfor ad_id = 1, ctr = (2/(2+1)) * 100 = 66.67\nfor ad_id = 2, ctr = (1/(1+2)) * 100 = 33.33\nfor ad_id = 3, ctr = (1/(1+1)) * 100 = 50.00\nfor ad_id = 5, ctr = 0.00, Note that ad_id = 5 has no clicks or views.\nNote that we don't care about Ignored Ads.\nSolution\nwith t1 as(\nselect ad_id, sum(case when action in ('Clicked') then 1 else 0 end) as clicked\nfrom ads\ngroup by ad_id\n)\n, t2 as\n(\nSelect ad_id as ad, sum(case when action in ('Clicked','Viewed') then 1 else 0 end) as total\nfrom ads\ngroup by ad_id\n)\nSelect a.ad_id, coalesce(round((clicked +0.0)/nullif((total +0.0),0)*100,2),0) as ctr\nfrom\n(\nselect *\nfrom t1 join t2\non t1.ad_id = t2.ad) a\norder by ctr desc, ad_id",
    "metadata": {
      "id": "SQL_3",
      "title": "Ads Performance",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_case_when",
        "sql_cte",
        "sql_null_handling"
      ],
      "solution_summary": "The query calculates the Click-Through Rate (CTR) for each ad by first aggregating the number of clicks and total views using Common Table Expressions (CTEs). It uses conditional aggregation to count clicks and views separately, then joins the results to compute the CTR. The final result is rounded and formatted, ensuring that ads with no clicks or views return a CTR of 0.00.",
      "url": "https://leetcode.com/problems/ads-performance/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Ads%20performance.sql"
    }
  },
  {
    "vector_content": "In social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Now given two tables as below:\nTable: friend_request\nTable: request_accepted\nWrite a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.\nFor the sample data above, your query should return the following result.\nNote:\nIt is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.\nIf there is no requests at all, you should return 0.00 as the accept_rate.\nExplanation: There are 4 unique accepted requests, and there are 5 requests in total.\nSo the rate is 0.80.\nSolution\nwith t1 as\n(\nselect distinct sender_id, send_to_id\nfrom friend_request\n), t2 as\n(\nselect distinct requester_id, accepter_id\nfrom request_accepted\n)\nSelect\nifnull((\nselect distinct\nround((select count(*) from t2) / ( select count(*) from t1),2) from t1,t2\n),0) 'accept_rate'",
    "metadata": {
      "id": "SQL_4",
      "title": "Friend Requests 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_distinct",
        "sql_cte",
        "sql_aggregation",
        "sql_null_handling"
      ],
      "solution_summary": "The query uses Common Table Expressions (CTEs) to create two distinct sets: one for unique friend requests and another for unique accepted requests. It then calculates the acceptance rate by dividing the count of unique accepted requests by the count of unique friend requests, rounding the result to two decimal places. If there are no requests, it returns 0.00 as the acceptance rate.",
      "url": "https://leetcode.com/problems/friend-requests-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Friend%20Requests%201.sql"
    }
  },
  {
    "vector_content": "Several friends at a cinema ticket office would like to reserve consecutive available seats.\nCan you help to query all the consecutive available seats order by the seat_id using the following cinema table?\nYour query should return the following result for the sample case above.\nNote:\nThe seat_id is an auto increment int, and free is bool ('1' means free, and '0' means occupied.).\nConsecutive available seats are more than 2(inclusive) seats consecutively available.\nSolution\nSelect seat_id\nfrom(\nselect seat_id, free,\nlead(free,1) over() as next,\nlag(free,1) over() as prev\nfrom cinema) a\nwhere a.free=True and (next = True or prev=True)\norder by seat_id",
    "metadata": {
      "id": "SQL_5",
      "title": "Consecutive Available Seats",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_window_function"
      ],
      "solution_summary": "The query uses window functions to identify the next and previous seat availability for each seat in the cinema table. It filters for seats that are free and either have a free seat next to them or a free seat before them. This approach efficiently captures groups of consecutive available seats, ensuring that only those with more than two consecutive free seats are returned.",
      "url": "https://leetcode.com/problems/consecutive-available-seats/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Consecutive%20available%20seats.sql"
    }
  },
  {
    "vector_content": "Table: Product\nTable: Sales\nproduct_id is a foreign key to Product table.\nWrite an SQL query that reports the best seller by total sales price, If there is a tie, report them all.\nThe query result format is in the following example:\nProduct table:\nSales table:\nResult table:\nBoth sellers with id 1 and 3 sold products with the most total price of 2800.\nSolution\nSelect a.seller_id\nfrom\n(select seller_id,\nrank() over(order by sum(price) desc) as rk\nfrom sales\ngroup by seller_id) a\nwhere a.rk=1",
    "metadata": {
      "id": "SQL_6",
      "title": "Sales Analysis 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_window_function"
      ],
      "solution_summary": "The query calculates the total sales price for each seller by grouping the sales data by seller_id and using the SUM function. It then applies the RANK window function to assign a rank based on the total sales price in descending order. Finally, it filters the results to return only those sellers with the highest total sales price, handling ties appropriately.",
      "url": "https://leetcode.com/problems/sales-analysis-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Sales%20Analysis%201.sql"
    }
  },
  {
    "vector_content": "A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\nFor example, according to the above table, we should output:\nSolution\nSelect name, population, area\nfrom world\nwhere population > 25000000 OR area>3000000",
    "metadata": {
      "id": "SQL_7",
      "title": "Big Countries",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_basic",
        "sql_filter"
      ],
      "solution_summary": "The query selects the name, population, and area of countries from the 'world' table. It filters the results to include only those countries with a population greater than 25 million or an area larger than 3 million square kilometers. This approach efficiently identifies 'big' countries based on the specified criteria.",
      "url": "https://leetcode.com/problems/big-countries/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Big%20Countries.sql"
    }
  },
  {
    "vector_content": "Table: Employees\nTable: EmployeeUNI\nWrite an SQL query to show the unique ID of each user, If a user doesn't have a unique ID replace just show null.\nThe query result format is in the following example:\nEmployees table:\nEmployeeUNI table:\nEmployeeUNI table:\nAlice and Bob don't have a unique ID, We will show null instead.\nThe unique ID of Meir is 2.\nThe unique ID of Winston is 3.\nThe unique ID of Jonathan is 1.\nSolution\nselect unique_id, name\nfrom employees e\nleft join\nemployeeuni u\non e.id = u.id\norder by e.id",
    "metadata": {
      "id": "SQL_8",
      "title": "Replace Employee Id With Unique Identifier",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_null_handling",
        "sql_sorting"
      ],
      "solution_summary": "The query performs a left join between the Employees and EmployeeUNI tables on the employee ID. This allows it to retrieve the unique ID for each employee, while returning null for those without a unique ID. The results are then ordered by employee ID for clarity.",
      "url": "https://leetcode.com/problems/replace-employee-id-with-unique-identifier/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Replace%20employee%20id%20with%20unique%20identifier.sql"
    }
  },
  {
    "vector_content": "Write a query to find the shortest distance between two points in these points.\nThe shortest distance is '1' obviously, which is from point '-1' to '0'. So the output is as below:\nSolution\nselect min(abs(abs(a.x)-abs(a.next_closest))) as shortest\nfrom(\nselect *,\nlead(x) over(order by x) as next_closest\nfrom point) a",
    "metadata": {
      "id": "SQL_9",
      "title": "Shortest Distance",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_window_function",
        "sql_aggregation"
      ],
      "solution_summary": "The query uses a window function to find the next closest point for each point in the dataset by ordering them. It then calculates the absolute difference between each point and its next closest point, and finally selects the minimum of these differences to determine the shortest distance. This approach efficiently identifies the closest points in a single pass through the data.",
      "url": "https://leetcode.com/problems/shortest-distance/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Shortest%20Distance.sql"
    }
  },
  {
    "vector_content": "Write an SQL query to find for each date, the number of distinct products sold and their names.\nThe sold-products names for each date should be sorted lexicographically.\nThe query result format is in the following example.\nActivities table:\nResult table:\nFor 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by comma.\nFor 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by comma.\nFor 2020-06-02, Sold item is (Mask), we just return it.\nSolution\nselect sell_date, count(distinct product) as num_sold, group_concat(distinct product) as products\nfrom activities\ngroup by 1\norder by 1",
    "metadata": {
      "id": "SQL_10",
      "title": "Group Sold Products By The Date",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_sorting",
        "sql_distinct"
      ],
      "solution_summary": "The query groups the sold products by their sale date using GROUP BY, counting the distinct products sold for each date. It utilizes COUNT(DISTINCT product) to get the number of unique products and GROUP_CONCAT(DISTINCT product) to concatenate the product names in lexicographical order. The results are then sorted by the sale date.",
      "url": "https://leetcode.com/problems/group-sold-products-by-the-date/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Group%20sold%20products%20by%20the%20date.sql"
    }
  },
  {
    "vector_content": "Table: Users\nname is the name of the user.\nTable: Rides\nuser_id is the id of the user who travelled the distance \"distance\".\nWrite an SQL query to report the distance travelled by each user.\nif two or more users travelled the same distance, order them by their name in ascending order.\nThe query result format is in the following example.\nUsers table:\nRides table:\nResult table:\nElvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than Lee.\nBob, Jonathan, Alex and Alice have only one ride and we just order them by the total distances of the ride.\nDonald didn't have any rides, the distance travelled by him is 0.\nSolution\nSelect U.name as name, coalesce(sum(R.distance),0) as travelled_distance\nfrom Users U left join Rides R\non R.user_id = U.id\ngroup by name\nOrder by travelled_distance desc, name",
    "metadata": {
      "id": "SQL_11",
      "title": "Top Travellers",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_sorting",
        "sql_join",
        "sql_null_handling"
      ],
      "solution_summary": "The query performs a left join between the Users and Rides tables on user_id to associate users with their travel distances. It uses the COALESCE function to ensure that users without rides are reported with a distance of 0. The results are grouped by user name and ordered first by the total distance travelled in descending order, and then by name in ascending order to handle ties.",
      "url": "https://leetcode.com/problems/top-travellers/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Top%20Travellers.sql"
    }
  },
  {
    "vector_content": "Table: Employee\nWrite an SQL query to find the team size of each of the employees.\nThe query result format is in the following example:\nEmployee Table:\nResult table:\nEmployees with Id 1,2,3 are part of a team with team_id = 8.\nEmployees with Id 4 is part of a team with team_id = 7.\nEmployees with Id 5,6 are part of a team with team_id = 9.\nSolution\nSelect employee_id, b.team_size\nfrom employee e\njoin\n(\nSelect team_id, count(team_id) as team_size\nfrom employee\ngroup by team_id) b\non e.team_id = b.team_id",
    "metadata": {
      "id": "SQL_12",
      "title": "Find The Team Size",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_join"
      ],
      "solution_summary": "The query calculates the team size for each employee by first aggregating the number of employees in each team using a subquery that groups by team_id. It then joins this result back to the Employee table on team_id to associate each employee with their respective team size. This approach efficiently provides the desired output by leveraging aggregation and joining techniques.",
      "url": "https://leetcode.com/problems/find-the-team-size/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Find%20the%20team%20size.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nNote that each session belongs to exactly one user.\nWrite an SQL query to find the average number of sessions per user for a period of 30 days ending 2019-07-27 inclusively, rounded to 2 decimal places. The sessions we want to count for a user are those with at least one activity in that time period.\nThe query result format is in the following example:\nActivity table:\nResult table:\nUser 1 and 2 each had 1 session in the past 30 days while user 3 had 2 sessions so the average is (1 + 1 + 2) / 3 = 1.33.\nSolution\nselect ifnull(round(avg(a.num),2),0) as average_sessions_per_user\nfrom (\nselect count(distinct session_id) as num\nfrom activity\nwhere activity_date between '2019-06-28' and '2019-07-27'\ngroup by user_id) a",
    "metadata": {
      "id": "SQL_13",
      "title": "User Activity For Past 30 Days 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct",
        "sql_date_processing"
      ],
      "solution_summary": "The query counts the distinct session IDs for each user within the specified 30-day period, grouping the results by user ID. It then calculates the average number of sessions per user and rounds the result to two decimal places. This approach effectively captures the required sessions while ensuring accurate averaging across users.",
      "url": "https://leetcode.com/problems/user-activity-for-past-30-days-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/User%20Activity%20for%20past%2030%20days%202.sql"
    }
  },
  {
    "vector_content": "Suppose that a website contains two tables,\nTable: Customers.\nTable: Orders.\nUsing the above tables as example, return the following:\nSolution\nSelect Name as Customers\nfrom Customers\nwhere id != All(select c.id\nfrom Customers c, Orders o\nwhere c.id = o.Customerid)",
    "metadata": {
      "id": "SQL_14",
      "title": "Customers Who Never Order",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_subquery"
      ],
      "solution_summary": "The query selects customer names from the Customers table where the customer ID is not present in the list of IDs from the Orders table. It uses a subquery to retrieve all customer IDs that have placed orders, and the main query filters out these IDs to find customers who have never ordered. This approach effectively identifies customers without any associated orders.",
      "url": "https://leetcode.com/problems/customers-who-never-order/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Customers%20who%20never%20order.sql"
    }
  },
  {
    "vector_content": "Table: Views\nNote that equal author_id and viewer_id indicate the same person.\nWrite an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id.\nThe query result format is in the following example:\nViews table:\nResult table:\nSolution\nselect distinct author_id as id\nfrom views\nwhere author_id = viewer_id\norder by author_id",
    "metadata": {
      "id": "SQL_15",
      "title": "Article Views",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_filter",
        "sql_distinct",
        "sql_sorting"
      ],
      "solution_summary": "The query selects distinct author_ids from the Views table where the author_id matches the viewer_id, indicating that the author viewed their own article. It then orders the results in ascending order by author_id. This approach efficiently identifies authors who have engaged with their own content.",
      "url": "https://leetcode.com/problems/article-views/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Article%20views.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nNote that each session belongs to exactly one user.\nWrite an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on some day if he/she made at least one activity on that day.\nThe query result format is in the following example:\nActivity table:\nResult table:\nNote that we do not care about days with zero active users.\nSolution\nSelect activity_date as day, count(distinct user_id) as active_users\nfrom activity\nwhere activity_date > '2019-06-26' and activity_date < '2019-07-27'\ngroup by activity_date",
    "metadata": {
      "id": "SQL_16",
      "title": "User Activity For Past 30 Days 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_filter",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct"
      ],
      "solution_summary": "The query selects the activity_date and counts the distinct user_ids for each date. It filters the results to include only those activities that occurred within the specified 30-day period ending on 2019-07-27. By grouping the results by activity_date, it effectively calculates the daily active user count for each day in that range.",
      "url": "https://leetcode.com/problems/user-activity-for-past-30-days-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/User%20activity%20for%20past%2030%20days%201.sql"
    }
  },
  {
    "vector_content": "Write a query to return the list of customers NOT referred by the person with id '2'.\nFor the sample data above, the result is:\nSolution\nSelect name\nfrom customer\nwhere referee_id != 2\nor referee_id is NULL",
    "metadata": {
      "id": "SQL_17",
      "title": "Find Customer Refree",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_filter",
        "sql_null_handling"
      ],
      "solution_summary": "The query selects the names of customers from the 'customer' table where the 'referee_id' is not equal to 2 or is NULL. This effectively filters out customers who were referred by the person with ID 2, ensuring that only those not referred by them are included in the result. The approach is efficient as it directly checks the 'referee_id' without the need for subqueries or joins.",
      "url": "https://leetcode.com/problems/find-customer-refree/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Find%20Customer%20Refree.sql"
    }
  },
  {
    "vector_content": "Table: Prices\nFor each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.\nTable: UnitsSold\nWrite an SQL query to find the average selling price for each product.\naverage_price should be rounded to 2 decimal places.\nThe query result format is in the following example:\nPrices table:\nUnitsSold table:\nResult table:\nAverage selling price = Total Price of Product / Number of products sold.\nAverage selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96\nAverage selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96\nSolution\nSelect d.product_id, round((sum(price*units)+0.00)/(sum(units)+0.00),2) as average_price\nfrom(\nSelect *\nfrom prices p\nnatural join\nunitssold u\nwhere u.purchase_date between p.start_date and p.end_date) d\ngroup by d.product_id",
    "metadata": {
      "id": "SQL_18",
      "title": "Average Selling Price",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_date_processing"
      ],
      "solution_summary": "The query calculates the average selling price for each product by joining the Prices and UnitsSold tables based on the purchase date falling within the price period. It uses aggregation to sum the total price multiplied by units sold and divides it by the total units sold, rounding the result to two decimal places. This approach ensures accurate calculation of the average price across different time periods for each product.",
      "url": "https://leetcode.com/problems/average-selling-price/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Average%20selling%20price.sql"
    }
  },
  {
    "vector_content": "Table: Project\nemployee_id is a foreign key to Employee table.\nTable: Employee\nWrite an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.\nThe query result format is in the following example:\nProject table:\nEmployee table:\nResult table:\nThe average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50\nSolution\nSelect a.project_id, round(sum(b.experience_years)/count(b.employee_id),2) as average_years\nfrom project as a\njoin\nemployee as b\non a.employee_id=b.employee_id\ngroup by a.project_id",
    "metadata": {
      "id": "SQL_19",
      "title": "Project Employees 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_join"
      ],
      "solution_summary": "The query joins the Project and Employee tables on employee_id to associate employees with their respective projects. It then calculates the average experience years for each project by summing the experience_years and dividing by the count of employees, rounding the result to two decimal places. This approach efficiently aggregates the data to provide the required average for each project.",
      "url": "https://leetcode.com/problems/project-employees-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Project%20Employees%201.sql"
    }
  },
  {
    "vector_content": "Table: Sessions\nduration is the time in seconds that a user has visited the application.\nYou want to know how long a user visits your application. You decided to create bins of \"[0-5>\", \"[5-10>\", \"[10-15>\" and \"15 minutes or more\" and count the number of sessions on it.\nWrite an SQL query to report the (bin, total) in any order.\nThe query result format is in the following example.\nSessions table:\nResult table:\nFor session_id 1, 2 and 3 have a duration greater or equal than 0 minutes and less than 5 minutes.\nFor session_id 4 has a duration greater or equal than 5 minutes and less than 10 minutes.\nThere are no session with a duration greater or equial than 10 minutes and less than 15 minutes.\nFor session_id 5 has a duration greater or equal than 15 minutes.\nSolution 2\n(Select '[0-5>' as bin,\nsum(case when duration/60 < 5 then 1 else 0 end) as total from Sessions)\nunion\n(Select '[5-10>' as bin,\nsum(case when ((duration/60 >= 5) and (duration/60 < 10)) then 1 else 0 end) as total from Sessions)\nunion\n(Select '[10-15>' as bin,\nsum(case when ((duration/60 >= 10) and (duration/60 < 15)) then 1 else 0 end) as total from Sessions)\nunion\n(Select '15 or more' as bin,\nsum(case when duration/60 >= 15 then 1 else 0 end) as total from Sessions)",
    "metadata": {
      "id": "SQL_20",
      "title": "Create Session Bar Chart",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_case_when",
        "sql_set_operations"
      ],
      "solution_summary": "The query creates four separate SELECT statements to count the number of sessions that fall into specific duration bins. Each SELECT uses a CASE WHEN statement to categorize the durations into the defined bins: '[0-5>', '[5-10>', '[10-15>', and '15 or more'. The results from these SELECT statements are combined using UNION to produce a single result set that shows the bin and the corresponding total count of sessions.",
      "url": "https://leetcode.com/problems/create-session-bar-chart/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Create%20Session%20bar%20chart.sql"
    }
  },
  {
    "vector_content": "Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\nFor example, return the following Ids for the above Weather table:\nSolution\nselect a.Id\nfrom weather a, weather b\nwhere a.Temperature>b.Temperature and  datediff(a.recorddate,b.recorddate)=1",
    "metadata": {
      "id": "SQL_21",
      "title": "Rising Temperature",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_date_processing"
      ],
      "solution_summary": "The query uses a self-join on the Weather table to compare the temperature of each date with the previous day's temperature. It filters the results to include only those dates where the temperature is higher than the previous day, using the DATEDIFF function to ensure the records are one day apart.",
      "url": "https://leetcode.com/problems/rising-temperature/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Rising%20Temperature.sql"
    }
  },
  {
    "vector_content": "Table: Project\nemployee_id is a foreign key to Employee table.\nTable: Employee\nWrite an SQL query that reports all the projects that have the most employees.\nThe query result format is in the following example:\nProject table:\nEmployee table:\nResult table:\nThe first project has 3 employees while the second one has 2.\nSolution\nselect a.project_id\nfrom(\nselect project_id,\nrank() over(order by count(employee_id) desc) as rk\nfrom project\ngroup by project_id) a\nwhere a.rk = 1",
    "metadata": {
      "id": "SQL_22",
      "title": "Project Employees 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_window_function"
      ],
      "solution_summary": "The query first groups the projects by project_id and counts the number of employees associated with each project. It then uses the RANK() window function to assign a rank based on the employee count in descending order. Finally, it filters the results to return only the project(s) with the highest number of employees, ensuring that all projects with the maximum count are included.",
      "url": "https://leetcode.com/problems/project-employees-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Project%20Employees%202.sql"
    }
  },
  {
    "vector_content": "Table: Actions\nWrite an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05.\nThe query result format is in the following example:\nActions table:\nResult table:\nNote that we only care about report reasons with non zero number of reports.\nSolution\nSelect extra as report_reason, count(distinct post_id) as report_count\nfrom actions\nwhere action_date = DATE_SUB(\"2019-07-5\", INTERVAL 1 DAY) and action='report'\ngroup by extra",
    "metadata": {
      "id": "SQL_23",
      "title": "Reported Posts",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_filter",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct"
      ],
      "solution_summary": "The query filters the Actions table for reports made yesterday, specifically on the action type 'report'. It then groups the results by the report reason and counts the distinct post IDs for each reason. This approach efficiently summarizes the number of reported posts by reason for the specified date.",
      "url": "https://leetcode.com/problems/reported-posts/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Reported%20posts.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.\nWrite a SQL query that reports the device that is first logged in for each player.\nThe query result format is in the following example:\nActivity table:\nResult table:\nSolution\nWith table1 as\n(\nSelect player_id, device_id,\nRank() OVER(partition by player_id\norder by event_date) as rk\nFrom Activity\n)\nSelect t.player_id, t.device_id\nfrom table1 as t\nwhere t.rk=1",
    "metadata": {
      "id": "SQL_24",
      "title": "Game Play Analysis 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_window_function",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to create a temporary result set that ranks each player's device logins by event date. It then selects the device with the highest rank (i.e., the first login) for each player. This approach efficiently isolates the first device used by each player during their game sessions.",
      "url": "https://leetcode.com/problems/game-play-analysis-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Game%20play%20analysis%202.sql"
    }
  },
  {
    "vector_content": "Solution\nWith t1 as\n(\nSelect *,\nrow_number() over(partition by email order by id) as rk\nfrom person\n)\nDelete from person\nwhere id in (Select t1.id from t1 where t1.rk>1)",
    "metadata": {
      "id": "SQL_25",
      "title": "Delete Duplicate Emails",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_window_function",
        "sql_cte",
        "sql_subquery"
      ],
      "solution_summary": "The solution uses a Common Table Expression (CTE) to assign a row number to each email grouped by the email address, ordered by the ID. It then deletes entries from the 'person' table where the row number is greater than one, effectively removing duplicate emails while keeping the first occurrence. This approach is efficient as it leverages window functions to identify duplicates in a single pass.",
      "url": "https://leetcode.com/problems/delete-duplicate-emails/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Delete%20duplicate%20emails.sql"
    }
  },
  {
    "vector_content": "Table: Sales\nproduct_id is a foreign key to Product table.\nNote that the price is per unit.\nTable: Product\nFor example:\nSales table:\nProduct table:\nResult table:\nSolution\nSelect a.product_name, b.year, b.price\nfrom product as a\njoin\nsales as b\non a.product_id = b.product_id",
    "metadata": {
      "id": "SQL_26",
      "title": "Product Sales Analysis 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join"
      ],
      "solution_summary": "The query selects the product name, year, and price by joining the Product and Sales tables on the product_id. This allows for retrieving relevant sales data associated with each product. The approach is efficient as it directly links the two tables based on their relationship, ensuring accurate results.",
      "url": "https://leetcode.com/problems/product-sales-analysis-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Product%20Sales%20Analysis%201.sql"
    }
  },
  {
    "vector_content": "Every employee has an Id, and there is also a column for the manager Id.\nGiven the Employee table, write a SQL query that finds out employees who earn more than their managers.\nFor the above table, Joe is the only employee who earns more than his manager.\nSolution\nselect a.Name as Employee\nfrom employee a, employee b\nwhere a.salary>b.salary and a.managerid=b.id",
    "metadata": {
      "id": "SQL_27",
      "title": "Employees Earning More Than Their Managers",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join"
      ],
      "solution_summary": "The query uses a self-join on the Employee table, where it compares the salary of each employee with that of their respective manager. It selects the names of employees whose salaries are greater than their managers' salaries by matching the employee's manager ID with the manager's ID. This approach effectively identifies employees earning more than their managers.",
      "url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Employees%20earning%20more%20than%20their%20managers.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.\nWrite an SQL query that reports the first login date for each player.\nThe query result format is in the following example:\nActivity table:\nResult table:\nSolution\nSelect player_id, min(event_date) as first_login\nfrom Activity\nGroup by player_id",
    "metadata": {
      "id": "SQL_28",
      "title": "Game Play Analysis 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by"
      ],
      "solution_summary": "The query selects the player_id and calculates the minimum event_date for each player using the MIN() function. By grouping the results by player_id, it effectively retrieves the first login date for each player. This approach is efficient as it directly aggregates the data without the need for additional filtering or complex operations.",
      "url": "https://leetcode.com/problems/game-play-analysis-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Game%20Play%20Analysis%201.sql"
    }
  },
  {
    "vector_content": "Table: Sales\nproduct_id is a foreign key to Product table.\nNote that the price is per unit.\nTable: Product\nWrite an SQL query that reports the total quantity sold for every product id.\nThe query result format is in the following example:\nSales table:\nProduct table:\nResult table:\nSolution\nSelect a.product_id, sum(a.quantity) as total_quantity\nfrom sales a\njoin\nproduct b\non a.product_id = b.product_id\ngroup by a.product_id",
    "metadata": {
      "id": "SQL_29",
      "title": "Product Sales Analysis 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_join"
      ],
      "solution_summary": "The query selects the product_id and calculates the total quantity sold by summing the quantity from the Sales table. It joins the Sales table with the Product table on the product_id to ensure that only valid products are considered. The results are grouped by product_id to provide the total quantity sold for each product.",
      "url": "https://leetcode.com/problems/product-sales-analysis-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Product%20Sales%20Analysis%202.sql"
    }
  },
  {
    "vector_content": "Table: Departments\nTable: Students\nWrite an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.\nThe query result format is in the following example:\nDepartments table:\nStudents table:\nResult table:\nJohn, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively.\ndepartment 14, 33, 74 and 77 doesn't exist in the Departments table.\nSolution\nSelect s.id, s.name\nfrom students s left join\ndepartments d\non s.department_id = d.id\nwhere d.name is null",
    "metadata": {
      "id": "SQL_30",
      "title": "Students With Invalid Departments",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_null_handling"
      ],
      "solution_summary": "The query performs a left join between the Students and Departments tables on the department_id. It then filters the results to find students whose department does not exist by checking for null values in the department name. This approach efficiently identifies students enrolled in non-existent departments.",
      "url": "https://leetcode.com/problems/students-with-invalid-departments/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Students%20with%20invalid%20departments.sql"
    }
  },
  {
    "vector_content": "A pupil Tim gets homework to identify whether three line segments could possibly form a triangle.\nHowever, this assignment is very heavy because there are hundreds of records to calculate.\nCould you help Tim by writing a query to judge whether these three sides can form a triangle,\nFor the sample data above, your query should return the follow result:\nSolution\nselect x, y, z,\ncase\nwhen x+y > z and x+z > y and  y+z > x  then 'Yes'\nwhen x=y and y=z then 'Yes'\nelse 'No'\nend as Triangle\nfrom triangle",
    "metadata": {
      "id": "SQL_31",
      "title": "Triangle Judgement",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_case_when"
      ],
      "solution_summary": "The query selects three line segments, x, y, and z, from the triangle table and uses a CASE WHEN statement to determine if they can form a triangle. It checks the triangle inequality conditions: x+y > z, x+z > y, and y+z > x. If these conditions are met, it returns 'Yes'; otherwise, it checks if all sides are equal and returns 'Yes' if true, or 'No' if neither condition is satisfied.",
      "url": "https://leetcode.com/problems/triangle-judgement/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Triangle%20Judgement.sql"
    }
  },
  {
    "vector_content": "Table: Countries\nTable: Weather\nThe query result format is in the following example:\nCountries table:\nWeather table:\nResult table:\nWe know nothing about average weather_state in Spain in November\nso we don't include it in the result table.\nSolution\nSelect c.country_name,\ncase when avg(w.weather_state)<=15 then 'Cold'\nwhen avg(w.weather_state)>=25 then 'Hot'\nelse 'Warm'\nfrom weather w join\ncountries c\non w.country_id = c.country_id\nwhere month(day) = 11\ngroup by c.country_name",
    "metadata": {
      "id": "SQL_32",
      "title": "Weather Type In Each Country",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_case_when",
        "sql_date_processing"
      ],
      "solution_summary": "The query joins the Countries and Weather tables on country_id and filters the results to include only records from November. It calculates the average weather_state for each country and categorizes the result into 'Cold', 'Warm', or 'Hot' using a CASE WHEN statement. The results are grouped by country_name, ensuring that only countries with weather data for November are included.",
      "url": "https://leetcode.com/problems/weather-type-in-each-country/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Weather%20type%20in%20each%20country.sql"
    }
  },
  {
    "vector_content": "Table: ActorDirector\nWrite a SQL query for a report that provides the pairs (actor_id, director_id) where the actor have cooperated with the director at least 3 times.\nExample:\nActorDirector table:\nResult table:\nThe only pair is (1, 1) where they cooperated exactly 3 times.\nSolution\nSelect actor_id, director_id\nfrom actordirector\ngroup by actor_id, director_id\nhaving count(*)>=3",
    "metadata": {
      "id": "SQL_33",
      "title": "Actors Who Cooperated With Directors Atleast Three Times",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by"
      ],
      "solution_summary": "The query selects actor_id and director_id from the ActorDirector table, grouping the results by these two columns. It uses the HAVING clause to filter the groups, returning only those pairs where the count of occurrences is at least three. This approach efficiently identifies actors who have collaborated with directors multiple times.",
      "url": "https://leetcode.com/problems/actors-who-cooperated-with-directors-atleast-three-times/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Actors%20who%20cooperated%20with%20Directors%20atleast%20three%20times.sql"
    }
  },
  {
    "vector_content": "Description\nGiven three tables: salesperson, company, orders.\nExample\nInput\nTable: salesperson\nTable: company\nTable: orders\noutput\nExplanation\nSolution\n# Takes higher time\n# Select distinct a.name\n# from(\n# select s.sales_id as sales, name\n# from salesperson s left join orders o\n# on s.sales_id = o.sales_id) a\n# where a.sales != all(select distinct sales_id from orders o join company c on o.com_id = c.com_id where o.com_id = any (select com_id from company where name = 'RED'))\n# Faster solution\nSELECT name\nFROM salesperson\nWHERE sales_id NOT IN (SELECT DISTINCT sales_id\nFROM orders\nWHERE com_id = (SELECT com_id\nFROM company\nWHERE name = 'RED')) ;",
    "metadata": {
      "id": "SQL_34",
      "title": "Sales Person",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_subquery",
        "sql_distinct"
      ],
      "solution_summary": "The query retrieves the names of salespersons whose sales IDs are not associated with any orders from the company named 'RED'. It uses a subquery to identify the sales IDs linked to the specified company and filters them out from the main selection. This approach is efficient as it directly checks for non-matching sales IDs without unnecessary joins.",
      "url": "https://leetcode.com/problems/sales-person/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Sales%20Person.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to get the second highest salary from the Employee table.\nFor example, given the above Employee table, the query should return 200 as the second highest salary.\nIf there is no second highest salary, then the query should return null.\nSolution\nselect max(salary) as SecondHighestSalary\nfrom employee\nwhere salary ! = (Select max(salary)\nfrom employee)",
    "metadata": {
      "id": "SQL_35",
      "title": "Second Highest Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_subquery"
      ],
      "solution_summary": "The query retrieves the maximum salary from the Employee table while excluding the highest salary. It uses a subquery to find the highest salary and then applies a filter to get the second highest. This approach is efficient as it directly targets the required value without needing to sort or group the entire dataset.",
      "url": "https://leetcode.com/problems/second-highest-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Second%20highest%20salary.sql"
    }
  },
  {
    "vector_content": "Swap all f and m values (i.e., change all f values to m and vice versa) with\na single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\nExample:\nSolution\nUpdate salary\nset sex = Case when sex = 'm' then 'f'\nwhen sex = 'f' then 'm'\nend;",
    "metadata": {
      "id": "SQL_36",
      "title": "Swap Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_case_when"
      ],
      "solution_summary": "The query updates the 'sex' column in the 'salary' table by using a CASE statement to swap 'm' values with 'f' values and vice versa. It effectively changes all occurrences of 'm' to 'f' and all occurrences of 'f' to 'm' in a single update statement. This approach is efficient as it performs the operation in one pass without the need for temporary tables.",
      "url": "https://leetcode.com/problems/swap-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Swap%20Salary.sql"
    }
  },
  {
    "vector_content": "Table: Delivery\nIf the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise it's called scheduled.\nWrite an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.\nThe query result format is in the following example:\nDelivery table:\nResult table:\nThe orders with delivery id 2 and 3 are immediate while the others are scheduled.\nSolution\nSelect\nRound(avg(case when order_date=customer_pref_delivery_date then 1 else 0 end)*100,2) as immediate_percentage\nfrom delivery",
    "metadata": {
      "id": "SQL_37",
      "title": "Immediate Food Delivery",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_case_when"
      ],
      "solution_summary": "The query calculates the percentage of immediate orders by comparing the order date with the customer's preferred delivery date using a CASE WHEN statement. It averages the results, where immediate orders are counted as 1 and scheduled orders as 0, and then multiplies by 100 to get the percentage. The final result is rounded to two decimal places for clarity.",
      "url": "https://leetcode.com/problems/immediate-food-delivery/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Immediate%20food%20delivery.sql"
    }
  },
  {
    "vector_content": "Please list out all classes which have more than or equal to 5 students.\nFor example, the table:\nSolution\nselect class\nfrom courses\ngroup by class\nhaving count(distinct student)>=5",
    "metadata": {
      "id": "SQL_38",
      "title": "Classes More Than 5 Students",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct"
      ],
      "solution_summary": "The query selects the class from the courses table, grouping the results by class. It uses the HAVING clause to filter for classes that have 5 or more distinct students. This approach efficiently identifies classes with a sufficient number of students by leveraging aggregation functions.",
      "url": "https://leetcode.com/problems/classes-more-than-5-students/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Classes%20more%20than%205%20students.sql"
    }
  },
  {
    "vector_content": "Table: Department\nThe month has values in [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"].\nThe query result format is in the following example:\nDepartment table:\nResult table:\nSolution\nselect id,\nsum(if(month='Jan',revenue,null)) as Jan_Revenue,\nsum(if(month='Feb',revenue,null)) as Feb_Revenue,\nsum(if(month='Mar',revenue,null)) as Mar_Revenue,\nsum(if(month='Apr',revenue,null)) as Apr_Revenue,\nsum(if(month='May',revenue,null)) as May_Revenue,\nsum(if(month='Jun',revenue,null)) as Jun_Revenue,\nsum(if(month='Jul',revenue,null)) as Jul_Revenue,\nsum(if(month='Aug',revenue,null)) as Aug_Revenue,\nsum(if(month='Sep',revenue,null)) as Sep_Revenue,\nsum(if(month='Oct',revenue,null)) as Oct_Revenue,\nsum(if(month='Nov',revenue,null)) as Nov_Revenue,\nsum(if(month='Dec',revenue,null)) as Dec_Revenue\nfrom Department\ngroup by id",
    "metadata": {
      "id": "SQL_39",
      "title": "Reformat Department Table",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by"
      ],
      "solution_summary": "The query aggregates revenue data from the Department table by summing the revenue for each month using conditional statements. It groups the results by the department ID to provide a monthly breakdown of revenue for each department. This approach efficiently organizes the data into a structured format, allowing for easy analysis of monthly revenues.",
      "url": "https://leetcode.com/problems/reformat-department-table/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Reformat%20department%20table.sql"
    }
  },
  {
    "vector_content": "Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.\nThe query result format is in the following example.\nTVProgram table:\nContent table:\nResult table:\n\"Leetcode Movie\" is not a content for kids.\n\"Alg. for Kids\" is not a movie.\n\"Database Sols\" is not a movie\n\"Alladin\" is a movie, content for kids and was streamed in June 2020.\n\"Cinderella\" was not streamed in June 2020.\nSolution\nselect distinct title\nfrom\n(select content_id, title\nfrom content\njoin\ntvprogram using (content_id)\nwhere month(program_date) = 6",
    "metadata": {
      "id": "SQL_40",
      "title": "Friendly Movies Streamed List",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_distinct",
        "sql_join",
        "sql_filter",
        "sql_date_processing"
      ],
      "solution_summary": "The query selects distinct movie titles from the content table where the content is marked as kid-friendly and of type 'Movies'. It then joins this filtered result with the tvprogram table to ensure that only movies streamed in June 2020 are included. This approach efficiently narrows down the results to meet the specified criteria.",
      "url": "https://leetcode.com/problems/friendly-movies-streamed-list/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Friendly%20Movies%20streamed%20list.sql"
    }
  },
  {
    "vector_content": "Table: Submissions\nEach row can be a post or comment on the post.\nparent_id is null for posts.\nparent_id for comments is sub_id for another post in the table.\nWrite an SQL query to find number of comments per each post.\nand must be sorted by post_id in ascending order.\nSubmissions may contain duplicate comments. You should count the number of unique comments per post.\nSubmissions may contain duplicate posts. You should treat them as one post.\nThe query result format is in the following example:\nSubmissions table:\nResult table:\nrepeated in the table, we counted it only once.\nThe post with id 12 has no comments in the table.\nThe comment with id 6 is a comment on a deleted post with id 7 so we ignored it.\nSolution\nSelect a.sub_id as post_id, coalesce(b.number_of_comments,0) as number_of_comments\nfrom(\nselect distinct sub_id from submissions where parent_id is null) a\nleft join(\nselect parent_id, count(distinct(sub_id)) as number_of_comments\nfrom submissions\ngroup by parent_id\nhaving parent_id = any(select sub_id from submissions where parent_id is null)) b\non a.sub_id = b.parent_id\norder by post_id",
    "metadata": {
      "id": "SQL_41",
      "title": "Number Of Comments Per Post",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct",
        "sql_join"
      ],
      "solution_summary": "The query first selects distinct post IDs from the Submissions table where parent_id is null, representing the posts. It then performs a left join with a subquery that counts the unique comments for each post, grouping by parent_id. The result is ordered by post_id, ensuring that posts without comments are included with a count of zero.",
      "url": "https://leetcode.com/problems/number-of-comments-per-post/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Number%20of%20comments%20per%20post.sql"
    }
  },
  {
    "vector_content": "Table: Students\nTable: Subjects\nTable: Examinations\nWrite an SQL query to find the number of times each student attended each exam.\nThe query result format is in the following example:\nStudents table:\nSubjects table:\nExaminations table:\nResult table:\nAlice attended Math exam 3 times, Physics exam 2 times and Programming exam 1 time.\nBob attended Math exam 1 time, Programming exam 1 time and didn't attend the Physics exam.\nAlex didn't attend any exam.\nJohn attended Math exam 1 time, Physics exam 1 time and Programming exam 1 time.\nSolution\nSelect a.student_id as student_id, a.student_name as student_name, a.subject_name as subject_name, coalesce(attended_exams,0) as attended_exams\nfrom(\nselect *\nfrom students\ncross join subjects\ngroup by student_id, student_name, subject_name) a\nleft join\n(Select e.student_id, student_name, subject_name, count(*) as attended_exams\nfrom examinations e join students s\non e.student_id = s.student_id\ngroup by e.student_id, student_name, subject_name) b\non a.student_id = b.student_id and a.subject_name =b.subject_name\norder by a.student_id asc, a.subject_name asc",
    "metadata": {
      "id": "SQL_42",
      "title": "Students And Examinations",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_null_handling"
      ],
      "solution_summary": "The query uses a cross join to combine all students with all subjects, ensuring that each student-subject pair is represented. It then performs a left join with a subquery that counts the number of times each student attended each exam, grouping by student and subject. The use of COALESCE ensures that students who did not attend any exams are still represented with a count of zero.",
      "url": "https://leetcode.com/problems/students-and-examinations/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Students%20and%20Examinations.sql"
    }
  },
  {
    "vector_content": "Table: Products\nTable: Orders\nproduct_id is a foreign key to Products table.\nunit is the number of products ordered in order_date.\nWrite an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.\nThe query result format is in the following example:\nProducts table:\nOrders table:\nResult table:\nProducts with product_id = 1 is ordered in February a total of (60 + 70) = 130.\nProducts with product_id = 2 is ordered in February a total of 80.\nProducts with product_id = 3 is ordered in February a total of (2 + 3) = 5.\nProducts with product_id = 4 was not ordered in February 2020.\nProducts with product_id = 5 is ordered in February a total of (50 + 50) = 100.\nSolution\nSelect a.product_name, a.unit\nfrom\n(select p.product_name, sum(unit) as unit\nfrom orders o\njoin products p\non o.product_id = p.product_id\nwhere month(order_date)=2 and year(order_date) = 2020\ngroup by o.product_id) a\nwhere a.unit>=100",
    "metadata": {
      "id": "SQL_43",
      "title": "List The Products Ordered In A Period",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_date_processing"
      ],
      "solution_summary": "The query joins the Products and Orders tables on product_id and filters the results to include only orders from February 2020. It then aggregates the total units ordered for each product using SUM and groups the results by product_id. Finally, it filters the aggregated results to return only those products with 100 or more units ordered.",
      "url": "https://leetcode.com/problems/list-the-products-ordered-in-a-period/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/List%20the%20products%20ordered%20in%20a%20period.sql"
    }
  },
  {
    "vector_content": "Table: Queries\nThe position column has a value from 1 to 500.\nThe rating column has a value from 1 to 5. Query with rating less than 3 is a poor query.\nWe define query quality as:\nThe average of the ratio between query rating and its position.\nWe also define poor query percentage as:\nThe percentage of all queries with rating less than 3.\nWrite an SQL query to find each query_name, the quality and poor_query_percentage.\nBoth quality and poor_query_percentage should be rounded to 2 decimal places.\nThe query result format is in the following example:\nQueries table:\nResult table:\nDog queries quality is ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50\nDog queries poor_ query_percentage is (1 / 3) * 100 = 33.33\nCat queries quality equals ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66\nCat queries poor_ query_percentage is (1 / 3) * 100 = 33.33\nSolution\nSelect query_name, round(sum(rating/position)/count(*),2) as quality,\nround(avg(case when rating<3 then 1 else 0 end)*100,2) as poor_query_percentage\nfrom queries\ngroup by query_name",
    "metadata": {
      "id": "SQL_44",
      "title": "Queries Quality And Percentage",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_case_when"
      ],
      "solution_summary": "The query calculates the quality of each query_name by averaging the ratio of rating to position and computes the poor query percentage by averaging a case statement that checks for ratings less than 3. It uses aggregation functions like SUM and COUNT, along with GROUP BY to group results by query_name. The results are rounded to two decimal places for clarity.",
      "url": "https://leetcode.com/problems/queries-quality-and-percentage/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Queries%20quality%20and%20percentage.sql"
    }
  },
  {
    "vector_content": "It is guaranteed that exactly one customer will have placed more orders than any other customer.\nSample Input\nSample Output\nExplanation\nThe customer with number '3' has two orders,\nwhich is greater than either customer '1' or '2' because each of them  only has one order.\nSo the result is customer_number '3'.\nSolution\nRanking them according to the number of orders to have same rank for\ncustomers with same number of orders\nWith t1 as\n(\nSelect customer_number,\nRank() over(order by count(customer_number) desc) as rk\nfrom orders\ngroup by customer_number\n)\nSelect t1.customer_number\nfrom t1\nwhere t1.rk=1",
    "metadata": {
      "id": "SQL_45",
      "title": "Customer Placing The Largest Number Of Orders",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_window_function",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to first aggregate the number of orders per customer using GROUP BY. It then applies a window function, RANK(), to rank customers based on the count of their orders in descending order. Finally, it selects the customer with the highest rank, which corresponds to the customer who placed the most orders.",
      "url": "https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Customer%20placing%20the%20largest%20number%20of%20orders%20.sql"
    }
  },
  {
    "vector_content": "Select all employee's name and bonus whose bonus is < 1000.\nTable:Employee\nTable: Bonus\nExample ouput:\nSolution\nSelect E.name, B.bonus\nFrom Employee E left join Bonus B\non E.empId = B.empId\nwhere B.bonus< 1000 or B.Bonus IS NULL",
    "metadata": {
      "id": "SQL_46",
      "title": "Employee Bonus",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join",
        "sql_null_handling"
      ],
      "solution_summary": "The query selects employee names and their bonuses by performing a left join between the Employee and Bonus tables on empId. It filters the results to include only those bonuses that are less than 1000 or where the bonus is null, ensuring that all employees are listed regardless of whether they have a bonus. This approach effectively captures employees without bonuses while applying the specified condition on bonuses.",
      "url": "https://leetcode.com/problems/employee-bonus/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Employee%20Bonus.sql"
    }
  },
  {
    "vector_content": "Table: Person\nTable: Address\nWrite a SQL query for a report that provides the following information for each person in the Person table,\nregardless if there is an address for each of those people:\nFirstName, LastName, City, State\nSolution\nselect FirstName, LastName, City, State\nfrom Person P left join Address A\non P.PersonId = A.PersonId",
    "metadata": {
      "id": "SQL_47",
      "title": "Combine Two Tables",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_join"
      ],
      "solution_summary": "The query retrieves the FirstName and LastName from the Person table and the City and State from the Address table. It uses a LEFT JOIN to ensure that all persons are included in the result, even if they do not have a corresponding address. This approach guarantees that the report contains information for every person, regardless of address availability.",
      "url": "https://leetcode.com/problems/combine-two-tables/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Combine%20two%20tables.sql"
    }
  },
  {
    "vector_content": "X city opened a new cinema, many people would like to go to this cinema.\nThe cinema also gives out a poster indicating the movies’ ratings and descriptions.\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'.\nOrder the result by rating.\nFor the example above, the output should be:\nSolution\nSelect *\nfrom cinema\nwhere id%2=1 and description not in ('boring')\norder by rating desc",
    "metadata": {
      "id": "SQL_48",
      "title": "Not Boring Movies",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_filter",
        "sql_sorting"
      ],
      "solution_summary": "The query selects all columns from the 'cinema' table where the movie ID is odd and the description is not 'boring'. It filters the results based on these criteria and orders them by rating in descending order. This approach efficiently narrows down the dataset to only the relevant movies while ensuring they are sorted by their ratings.",
      "url": "https://leetcode.com/problems/not-boring-movies/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Not%20Boring%20movies.sql"
    }
  },
  {
    "vector_content": "Can you write a SQL query to find the biggest number, which only appears once.\nFor the sample data above, your query should return the following result:\nNote:\nIf there is no such number, just output null.\nSolution\nSelect max(a.num) as num\nfrom\n(\nselect num, count(*)\nfrom my_numbers\ngroup by num\nhaving count(*)=1\n) a",
    "metadata": {
      "id": "SQL_49",
      "title": "Biggest Single Number",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_subquery"
      ],
      "solution_summary": "The query first groups the numbers in the 'my_numbers' table and counts their occurrences. It then filters to retain only those numbers that appear exactly once. Finally, it selects the maximum value from this filtered set, returning the largest single occurrence number or null if none exist.",
      "url": "https://leetcode.com/problems/biggest-single-number/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Biggest%20Single%20number.sql"
    }
  },
  {
    "vector_content": "For example, your query should return the following for the above table:\nSolution\nSelect Email\nfrom\n(Select Email, count(Email)\nfrom person\ngroup by Email\nhaving count(Email)>1) a",
    "metadata": {
      "id": "SQL_50",
      "title": "Duplicate Emails",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_easy",
        "sql_aggregation",
        "sql_group_by",
        "sql_subquery"
      ],
      "solution_summary": "The query identifies duplicate emails by first counting the occurrences of each email in the 'person' table. It groups the results by email and filters those with a count greater than one using the HAVING clause. The outer query then selects only the emails that have duplicates, ensuring an efficient retrieval of the required data.",
      "url": "https://leetcode.com/problems/duplicate-emails/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Easy/Duplicate%20Emails.sql"
    }
  },
  {
    "vector_content": "X city built a new stadium, each day many people visit it and the stats are saved as these columns: id, visit_date, people\nPlease write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive).\nFor the sample data above, the output is:\nNote:\nEach day only have one row record, and the dates are increasing with id increasing.\nSolution\nWITH t1 AS (\nSELECT id,\nvisit_date,\npeople,\nid - ROW_NUMBER() OVER(ORDER BY visit_date) AS dates\nFROM stadium\nWHERE people >= 100)\nSELECT t1.id,\nt1.visit_date,\nt1people\nFROM t1\nLEFT JOIN (\nSELECT dates,\nCOUNT(*) as total\nFROM t1\nGROUP BY dates) AS b\nUSING (dates)\nWHERE b.total > 2",
    "metadata": {
      "id": "SQL_51",
      "title": "Human Traffic Of Stadium",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_cte",
        "sql_window_function",
        "sql_group_by",
        "sql_join"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to filter records with 100 or more people and calculates a 'dates' value to identify consecutive rows. It then counts the occurrences of these consecutive rows and filters for those with more than two entries. Finally, it joins the results to display the relevant records.",
      "url": "https://leetcode.com/problems/human-traffic-of-stadium/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Human%20traffic%20of%20stadium.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).\nExplanation:\nIn IT department, Max earns the highest salary, both Randy and Joe earn the second highest salary,\nand Will earns the third highest salary.\nThere are only two employees in the Sales department,\nHenry earns the highest salary while Sam earns the second highest salary.\nSolution\nselect a.department, a.employee, a.salary\nfrom (\nselect d.name as department, e.name as employee, salary,\ndense_rank() over(Partition by d.name order by salary desc) as rk\nfrom Employee e join Department d\non e.departmentid = d.id) a\nwhere a.rk<4",
    "metadata": {
      "id": "SQL_52",
      "title": "Department Top Three Salaries",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_join",
        "sql_window_function"
      ],
      "solution_summary": "The query uses a common table expression to join the Employee and Department tables, selecting the department name, employee name, and salary. It applies the DENSE_RANK() window function to rank salaries within each department in descending order. Finally, it filters the results to include only the top three salaries per department.",
      "url": "https://leetcode.com/problems/department-top-three-salaries/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Department%20top%20three%20salaries.sql"
    }
  },
  {
    "vector_content": "Given two tables as below, write a query to display the comparison result (higher/lower/same) of the\naverage salary of employees in a department to the company's average salary.\nTable: salary\nSo for the sample data above, the result is:\nExplanation\nIn March, the company's average salary is (9000+6000+10000)/3 = 8333.33...\nThe average salary for department '1' is 9000, which is the salary of employee_id '1' since there is only one employee in this department. So the comparison result is 'higher' since 9000 > 8333.33 obviously.\nThe average salary of department '2' is (6000 + 10000)/2 = 8000, which is the average of employee_id '2' and '3'. So the comparison result is 'lower' since 8000 < 8333.33.\nWith he same formula for the average salary comparison in February, the result is 'same' since both the department '1' and '2' have the same average salary with the company, which is 7000.\nSolution\nwith t1 as(\nselect date_format(pay_date,'%Y-%m') as pay_month, department_id, avg(amount) over(partition by month(pay_date),department_id) as dept_avg,\navg(amount) over(partition by month(pay_date)) as comp_avg\nfrom salary s join employee e\nusing (employee_id))\nselect distinct pay_month, department_id,\ncase when dept_avg>comp_avg then \"higher\"\nwhen dept_avg = comp_avg then \"same\"\nelse \"lower\"\nend as comparison\nfrom t1\norder by 1 desc",
    "metadata": {
      "id": "SQL_53",
      "title": "Average Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_join",
        "sql_window_function",
        "sql_case_when",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to calculate the average salary for each department and the company's average salary by month. It employs window functions to compute these averages while joining the salary and employee tables. Finally, it compares the department's average salary to the company's average and categorizes the result as 'higher', 'lower', or 'same'.",
      "url": "https://leetcode.com/problems/average-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Average%20Salary.sql"
    }
  },
  {
    "vector_content": "Table: Orders\norder_date is the date when item_id was ordered by the customer with id customer_id.\nTable: Items\nitem_name is the name of the item.\nitem_category is the category of the item.\nYou are the business owner and would like to obtain a sales report for category items and day of the week.\nWrite an SQL query to report how many units in each category have been ordered on each day of the week.\nThe query result format is in the following example:\nOrders table:\nItems table:\nResult table:\nOn Monday (2020-06-01, 2020-06-08) were sold a total of 20 units (10 + 10) in the category Book (ids: 1, 2).\nOn Tuesday (2020-06-02) were sold a total of 5 units  in the category Book (ids: 1, 2).\nOn Wednesday (2020-06-03) were sold a total of 5 units in the category Phone (ids: 3, 4).\nOn Thursday (2020-06-04) were sold a total of 1 unit in the category Phone (ids: 3, 4).\nOn Friday (2020-06-05) were sold 10 units in the category Book (ids: 1, 2) and 5 units in Glasses (ids: 5).\nOn Saturday there are no items sold.\nOn Sunday (2020-06-14, 2020-06-21) were sold a total of 10 units (5 +5) in the category Phone (ids: 3, 4).\nThere are no sales of T-Shirt.\nSolution\nwith t1 as(\nselect distinct item_category,\ncase when dayname(order_date)='Monday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Monday,\nCase when dayname(order_date)='Tuesday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Tuesday,\nCase when dayname(order_date)='Wednesday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Wednesday,\nCase when dayname(order_date)='Thursday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Thursday,\nCase when dayname(order_date)='Friday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Friday,\nCase when dayname(order_date)='Saturday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Saturday,\nCase when dayname(order_date)='Sunday' then sum(quantity) over(partition by item_category,dayname(order_date)) else 0 end as Sunday\nfrom orders o\nright join items i\nusing (item_id))\nselect item_category as category, sum(Monday) as Monday, sum(Tuesday) as Tuesday, sum(Wednesday) Wednesday, sum(Thursday) Thursday,\nsum(Friday) Friday, sum(Saturday) Saturday, sum(Sunday) Sunday\nfrom t1\ngroup by item_category",
    "metadata": {
      "id": "SQL_54",
      "title": "Sales By Day Of The Week",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_case_when",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to aggregate sales data by item category and day of the week. It employs the CASE WHEN statement to conditionally sum the quantities sold for each day, partitioned by item category. Finally, the results are grouped by item category to provide a comprehensive sales report for each day of the week.",
      "url": "https://leetcode.com/problems/sales-by-day-of-the-week/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Sales%20by%20day%20of%20the%20week.sql"
    }
  },
  {
    "vector_content": "Table: Student\nstudent_name is the name of the student.\nTable: Exam\nStudent with student_id got score points in exam with id exam_id.\nA \"quite\" student is the one who took at least one exam and didn't score neither the high score nor the low score.\nWrite an SQL query to report the students (student_id, student_name) being \"quiet\" in ALL exams.\nThe query result format is in the following example.\nStudent table:\nExam table:\nResult table:\nFor exam 1: Student 1 and 3 hold the lowest and high score respectively.\nFor exam 2: Student 1 hold both highest and lowest score.\nFor exam 3 and 4: Studnet 1 and 4 hold the lowest and high score respectively.\nStudent 2 and 5 have never got the highest or lowest in any of the exam.\nSince student 5 is not taking any exam, he is excluded from the result.\nSo, we only return the information of Student 2.\nSolution\nwith t1 as(\nselect student_id\nfrom\n(select *,\nmin(score) over(partition by exam_id) as least,\nmax(score) over(partition by exam_id) as most\nfrom exam) a\nwhere least = score or most = score)\nselect distinct student_id, student_name\nfrom exam join student\nusing (student_id)\nwhere student_id != all(select student_id from t1)\norder by 1",
    "metadata": {
      "id": "SQL_55",
      "title": "Find The Quiet Students In The Exam",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_window_function",
        "sql_cte",
        "sql_join",
        "sql_distinct"
      ],
      "solution_summary": "The query first identifies students who scored either the highest or lowest in any exam using a Common Table Expression (CTE) with window functions to calculate the minimum and maximum scores per exam. It then selects distinct students from the Exam and Student tables who are not in the list of students identified as scoring the highest or lowest in any exam. This approach ensures that only 'quiet' students, who have taken exams but never scored at the extremes, are returned.",
      "url": "https://leetcode.com/problems/find-the-quiet-students-in-the-exam/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Find%20the%20quiet%20students%20in%20the%20exam.sql"
    }
  },
  {
    "vector_content": "For the sample input, the output is:\nSolution\nselect min(case when continent = 'America' then name end) as America,\nmin(case when continent = 'Asia' then name end) as Asia,\nmin(case when continent = 'Europe' then name end) as Europe\nfrom\n(select *, row_number() over(partition by continent order by name) as rn\nfrom student) a\ngroup by rn",
    "metadata": {
      "id": "SQL_56",
      "title": "Students Report By Geography",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_group_by",
        "sql_window_function",
        "sql_case_when"
      ],
      "solution_summary": "The query uses a subquery to assign a row number to each student within their respective continent, ordered by name. It then aggregates the results by grouping on the row number and uses conditional aggregation with CASE WHEN to select the minimum name for each continent. This approach efficiently organizes the data by continent while ensuring that the names are sorted correctly.",
      "url": "https://leetcode.com/problems/students-report-by-geography/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Students%20report%20by%20geography.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users.\nFor the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\nCredits:\nSpecial thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.\nSolution\nwith t1 as(\nselect request_at, count(status) as total\nfrom trips\nwhere client_id = any(select users_id\nfrom users\nwhere banned != 'Yes')\nand driver_id = any(select users_id\nfrom users\nwhere banned != 'Yes')\nand request_at between '2013-10-01' and '2013-10-03'\ngroup by request_at),\nt2 as\n( select request_at, count(status) as cancel\nfrom trips\nwhere client_id = any(select users_id\nfrom users\nwhere banned != 'Yes')\nand driver_id = any(select users_id\nfrom users\nwhere banned != 'Yes')\nand request_at between '2013-10-01' and '2013-10-03'\nand status != 'completed'\ngroup by request_at\n)\nselect request_at as Day, coalesce(round((cancel+0.00)/(total+0.00),2),0) as \"Cancellation Rate\"\nfrom t1 left join t2\nusing(request_at)",
    "metadata": {
      "id": "SQL_57",
      "title": "Trips And Users",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The query uses Common Table Expressions (CTEs) to calculate the total number of requests and the number of canceled requests made by unbanned users within a specified date range. It filters the trips based on the status of both the client and driver being unbanned and groups the results by the request date. Finally, it computes the cancellation rate by dividing the number of canceled requests by the total requests, rounding the result to two decimal places.",
      "url": "https://leetcode.com/problems/trips-and-users/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Trips%20and%20Users.sql"
    }
  },
  {
    "vector_content": "In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0 + 0) / 2 = 0.\nWrite a query to find the median of all numbers and name the result as median.\nSolution\nwith t1 as(\nselect *,\nsum(frequency) over(order by number) as cum_sum, (sum(frequency) over())/2 as middle\nfrom numbers)\nselect avg(number) as median\nfrom t1\nwhere middle between (cum_sum - frequency) and cum_sum",
    "metadata": {
      "id": "SQL_58",
      "title": "Find Median Given Frequency Of Numbers",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_window_function",
        "sql_cte",
        "sql_aggregation"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to calculate a cumulative sum of frequencies and the middle value of the total frequency. It then selects the average of the numbers where the middle value falls between the cumulative sum minus the current frequency and the cumulative sum. This approach efficiently identifies the median by leveraging window functions to handle the frequency distribution.",
      "url": "https://leetcode.com/problems/find-median-given-frequency-of-numbers/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Find%20median%20given%20frequency%20of%20numbers.sql"
    }
  },
  {
    "vector_content": "Write a SQL to get the cumulative sum of an employee's salary over a period of 3 months but exclude the most recent month.\nThe result should be displayed by 'Id' ascending, and then by 'Month' descending.\nExample\nInput\nOutput\nExplanation\nEmployee '1' has 3 salary records for the following 3 months except the most recent month '4': salary 40 for month '3', 30 for month '2' and 20 for month '1'\nSo the cumulative sum of salary of this employee over 3 months is 90(40+30+20), 50(30+20) and 20 respectively.\nEmployee '2' only has one salary record (month '1') except its most recent month '2'.\nEmploy '3' has two salary records except its most recent pay month '4': month '3' with 60 and month '2' with 40. So the cumulative salary is as following.\nSolution\nwith t1 as(\nselect *, max(month) over(partition by id) as recent_month\nfrom employee)\nselect id, month, sum(salary) over(partition by id order by month rows between 2 preceding and current row) as salary\nfrom t1\nwhere month<recent_month\norder by 1, 2 desc",
    "metadata": {
      "id": "SQL_59",
      "title": "Cumulative Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_window_function",
        "sql_cte",
        "sql_aggregation",
        "sql_sorting"
      ],
      "solution_summary": "The query first creates a Common Table Expression (CTE) to determine the most recent month for each employee using a window function. It then calculates the cumulative salary for each employee over the previous three months, excluding the most recent month. The results are filtered to only include months less than the most recent month and are ordered by employee ID in ascending order and month in descending order.",
      "url": "https://leetcode.com/problems/cumulative-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Cumulative%20Salary.sql"
    }
  },
  {
    "vector_content": "Table: Visits\nTable: Transactions\nA bank wants to draw a chart of the number of transactions bank visitors did in one visit to the bank and the corresponding number of visitors who have done this number of transaction in one visit.\nWrite an SQL query to find how many users visited the bank and didn't do any transactions, how many visited the bank and did one transaction and so on.\ntransactions_count which is the number of transactions done in one visit.\nvisits_count which is the corresponding number of users who did transactions_count in one visit to the bank.\ntransactions_count should take all values from 0 to max(transactions_count) done by one or more users.\nThe query result format is in the following example:\nVisits table:\nTransactions table:\nResult table:\n* For transactions_count = 0, The visits (1, \"2020-01-01\"), (2, \"2020-01-02\"), (12, \"2020-01-01\") and (19, \"2020-01-03\") did no transactions so visits_count = 4.\n* For transactions_count = 1, The visits (2, \"2020-01-03\"), (7, \"2020-01-11\"), (8, \"2020-01-28\"), (1, \"2020-01-02\") and (1, \"2020-01-04\") did one transaction so visits_count = 5.\n* For transactions_count = 2, No customers visited the bank and did two transactions so visits_count = 0.\n* For transactions_count = 3, The visit (9, \"2020-01-25\") did three transactions so visits_count = 1.\n* For transactions_count >= 4, No customers visited the bank and did more than three transactions so we will stop at transactions_count = 3\nSolution\nWITH RECURSIVE t1 AS(\nSELECT visit_date,\nCOALESCE(num_visits,0) as num_visits,\nCOALESCE(num_trans,0) as num_trans\nFROM ((\nSELECT visit_date, user_id, COUNT(*) as num_visits\nFROM visits\nGROUP BY 1, 2) AS a\nLEFT JOIN\n(\nSELECT transaction_date,\nuser_id,\ncount(*) as num_trans\nFROM transactions\nGROUP BY 1, 2) AS b\nON a.visit_date = b.transaction_date and a.user_id = b.user_id)\n),\nt2 AS (\nSELECT MAX(num_trans) as trans\nFROM t1\nUNION ALL\nSELECT trans-1\nFROM t2\nWHERE trans >= 1)\nSELECT trans as transactions_count,\nCOALESCE(visits_count,0) as visits_count\nFROM t2 LEFT JOIN (\nSELECT num_trans as transactions_count, COALESCE(COUNT(*),0) as visits_count\nFROM t1\nGROUP BY 1\nORDER BY 1) AS a\nON a.transactions_count = t2.trans\nORDER BY 1",
    "metadata": {
      "id": "SQL_60",
      "title": "Number Of Transactions Per Visit",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The query uses Common Table Expressions (CTEs) to first aggregate the number of visits and transactions per user. It then recursively generates a list of transaction counts from the maximum down to zero. Finally, it joins this list with the aggregated results to count how many users correspond to each transaction count, ensuring that all counts from 0 to the maximum are included.",
      "url": "https://leetcode.com/problems/number-of-transactions-per-visit/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Number%20of%20transactions%20per%20visit.sql"
    }
  },
  {
    "vector_content": "Table: Spending\nWrite an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date.\nThe query result format is in the following example:\nSpending table:\nResult table:\nOn 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.\nOn 2019-07-02, user 2 purchased using mobile only, user 3 purchased using desktop only and no one purchased using both platforms.\nSolution\nSELECT p.spend_date, p.platform, IFNULL(SUM(amount), 0) total_amount, COUNT(DISTINCT u.user_id) total_users\nFROM\n(\nSELECT DISTINCT(spend_date), 'desktop' platform FROM Spending\nUNION\nSELECT DISTINCT(spend_date), 'mobile' platform FROM Spending\nUNION\nSELECT DISTINCT(spend_date), 'both' platform FROM Spending\n) p LEFT JOIN\n(SELECT user_id, spend_date, SUM(amount) amount, (CASE WHEN COUNT(DISTINCT platform)>1 THEN \"both\" ELSE platform END) platform\nFROM Spending\nGROUP BY spend_date, user_id) u\nON p.platform = u.platform AND p.spend_date=u.spend_date\nGROUP BY p.spend_date, p.platform",
    "metadata": {
      "id": "SQL_61",
      "title": "User Purchase Platform",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_case_when"
      ],
      "solution_summary": "The query first creates a derived table to list distinct spending dates and platforms (desktop, mobile, both). It then joins this table with another derived table that aggregates spending amounts and counts distinct users based on their spending behavior. The CASE WHEN statement is used to categorize users into 'both' if they used multiple platforms. Finally, the results are grouped by spend date and platform to provide the total amount spent and total users for each category.",
      "url": "https://leetcode.com/problems/user-purchase-platform/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/User%20purchase%20platform.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions.\nSolution\nselect id, company, salary\nfrom\n(select *,\nrow_number() over(partition by company order by salary) as rn,\ncount(*) over(partition by company) as cnt\nfrom employee) a\nwhere rn between cnt/2 and cnt/2+1",
    "metadata": {
      "id": "SQL_62",
      "title": "Median Employee Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_window_function"
      ],
      "solution_summary": "The query calculates the median salary for each company by using window functions. It assigns a row number to each salary within its company and counts the total number of salaries. The median is then determined by selecting the rows that fall in the middle of the ordered salary list, handling both even and odd counts appropriately.",
      "url": "https://leetcode.com/problems/median-employee-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Median%20Employee%20Salary.sql"
    }
  },
  {
    "vector_content": "Table: Players\nTable: Matches\nEach row is a record of a match, first_player and second_player contain the player_id of each match.\nfirst_score and second_score contain the number of points of the first_player and second_player respectively.\nYou may assume that, in each match, players belongs to the same group.\nThe winner in each group is the player who scored the maximum total points within the group. In the case of a tie,\nthe lowest player_id wins.\nWrite an SQL query to find the winner in each group.\nThe query result format is in the following example:\nPlayers table:\nMatches table:\nResult table:\nSolution\nwith t1 as(\nselect first_player, sum(first_score) as total\nfrom\n(select first_player, first_score\nfrom matches\nunion all\nselect second_player, second_score\nfrom matches) a\ngroup by 1),\nt2 as(\nselect *, coalesce(total,0) as score\nfrom players p left join t1\non p.player_id = t1.first_player)\nselect group_id, player_id\nfrom\n(select *, row_number() over(partition by group_id order by group_id, score desc) as rn\nfrom t2) b\nwhere b.rn = 1",
    "metadata": {
      "id": "SQL_63",
      "title": "Tournament Winners",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_window_function"
      ],
      "solution_summary": "The query first aggregates the scores of players from the Matches table using a Common Table Expression (CTE) to calculate total points for each player. It then performs a left join with the Players table to ensure all players are included, even those without matches. Finally, it uses a window function to rank players within each group based on their scores, selecting the top player for each group, resolving ties by player_id.",
      "url": "https://leetcode.com/problems/tournament-winners/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Tournament%20Winners.sql"
    }
  },
  {
    "vector_content": "Table: Failed\nTable: Succeeded\nA system is running one task every day. Every task is independent of the previous tasks. The tasks can fail or succeed.\nWrite an SQL query to generate a report of period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31.\nperiod_state is 'failed' if tasks in this interval failed or 'succeeded' if tasks in this interval succeeded. Interval of days are retrieved as start_date and end_date.\nOrder result by start_date.\nThe query result format is in the following example:\nFailed table:\nSucceeded table:\nResult table:\nThe report ignored the system state in 2018 as we care about the system in the period 2019-01-01 to 2019-12-31.\nFrom 2019-01-01 to 2019-01-03 all tasks succeeded and the system state was \"succeeded\".\nFrom 2019-01-04 to 2019-01-05 all tasks failed and system state was \"failed\".\nFrom 2019-01-06 to 2019-01-06 all tasks succeeded and system state was \"succeeded\".\nSolution\nwith t1 as(\nselect min(success_date) as start_date, max(success_date) as end_date, state\nfrom(\nselect *, date_sub(success_date, interval row_number() over(order by success_date) day) as diff, 1 as state\nfrom succeeded\nwhere success_date between \"2019-01-01\" and \"2019-12-31\") a\ngroup by diff),\nt2 as(\nselect min(fail_date) as start_date, max(fail_date) as end_date, state\nfrom(\nselect *, date_sub(fail_date, interval row_number() over(order by fail_date) day) as diff, 0 as state\nfrom failed\nwhere fail_date between \"2019-01-01\" and \"2019-12-31\") b\ngroup by diff)\nselect\ncase when c.state = 1 then \"succeeded\"\nelse \"failed\"\nend as period_state,start_date, end_date\nfrom(\nselect *\nfrom t1\nunion all\nselect *\nfrom t2) c\norder by start_date",
    "metadata": {
      "id": "SQL_64",
      "title": "Report Contiguous Dates",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_cte",
        "sql_window_function",
        "sql_group_by",
        "sql_case_when"
      ],
      "solution_summary": "The query uses Common Table Expressions (CTEs) to first aggregate the success and failure dates into continuous intervals by calculating a 'diff' value that groups consecutive dates. It then combines the results from both CTEs using a UNION ALL operation and assigns a 'period_state' based on whether the interval is from the succeeded or failed tasks. Finally, the results are ordered by the start date, providing a clear report of the task states throughout the year.",
      "url": "https://leetcode.com/problems/report-contiguous-dates/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Report%20contiguous%20dates.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.\nWe define the install date of a player to be the first login day of that player.\nWe also define day 1 retention of some date X to be the number of players whose install date is X and they logged back in on the day right after X, divided by the number of players whose install date is X, rounded to 2 decimal places.\nWrite an SQL query that reports for each install date, the number of players that installed the game on that day and the day 1 retention.\nThe query result format is in the following example:\nActivity table:\nResult table:\nPlayer 1 and 3 installed the game on 2016-03-01 but only player 1 logged back in on 2016-03-02 so the\nday 1 retention of 2016-03-01 is 1 / 2 = 0.50\nPlayer 2 installed the game on 2017-06-25 but didn't log back in on 2017-06-26 so the day 1 retention of 2017-06-25 is 0 / 1 = 0.00\nSolution\nwith t1 as(\nselect *,\nrow_number() over(partition by player_id order by event_date) as rnk,\nmin(event_date) over(partition by player_id) as install_dt,\nlead(event_date,1) over(partition by player_id order by event_date) as nxt\nfrom Activity)\nselect distinct install_dt,\ncount(distinct player_id) as installs,\nround(sum(case when nxt=event_date+1 then 1 else 0 end)/count(distinct player_id),2) as Day1_retention\nfrom t1\nwhere rnk = 1\ngroup by 1\norder by 1",
    "metadata": {
      "id": "SQL_65",
      "title": "Game Play Analysis 5",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_window_function",
        "sql_cte",
        "sql_aggregation",
        "sql_group_by"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to first assign a rank to each player's events and determine their install date and the next event date. It then calculates the number of installs for each install date and computes the day 1 retention by checking if the next event date is the day after the install date. The results are grouped by install date and ordered accordingly.",
      "url": "https://leetcode.com/problems/game-play-analysis-5/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Game%20Play%20Analysis%205.sql"
    }
  },
  {
    "vector_content": "Table: Product\nproduct_name is the name of the product.\nTable: Sales\nperiod_start and period_end indicates the start and end date for sales period, both dates are inclusive.\nThe average_daily_sales column holds the average daily sales amount of the items for the period.\nWrite an SQL query to report the Total sales amount of each item for each year, with corresponding product name, product_id, product_name and report_year.\nThe query result format is in the following example:\nProduct table:\nSales table:\nResult table:\nLC Phone was sold for the period of 2019-01-25 to 2019-02-28, and there are 35 days for this period. Total amount 35*100 = 3500.\nLC T-shirt was sold for the period of 2018-12-01 to 2020-01-01, and there are 31, 365, 1 days for years 2018, 2019 and 2020 respectively.\nLC Keychain was sold for the period of 2019-12-01 to 2020-01-31, and there are 31, 31 days for years 2019 and 2020 respectively.\nSolution\nSELECT\nb.product_id,\na.product_name,\na.yr AS report_year,\nCASE\nWHEN YEAR(b.period_start)=YEAR(b.period_end) AND a.yr=YEAR(b.period_start) THEN DATEDIFF(b.period_end,b.period_start)+1\nWHEN a.yr=YEAR(b.period_start) THEN DATEDIFF(DATE_FORMAT(b.period_start,'%Y-12-31'),b.period_start)+1\nWHEN a.yr=YEAR(b.period_end) THEN DAYOFYEAR(b.period_end)\nWHEN a.yr>YEAR(b.period_start) AND a.yr<YEAR(b.period_end) THEN 365\nELSE 0\nEND * average_daily_sales AS total_amount\nFROM\n(SELECT product_id,product_name,'2018' AS yr FROM Product\nUNION\nSELECT product_id,product_name,'2019' AS yr FROM Product\nUNION\nSELECT product_id,product_name,'2020' AS yr FROM Product) a\nJOIN\nSales b\nON a.product_id=b.product_id\nHAVING total_amount > 0\nORDER BY b.product_id,a.yr",
    "metadata": {
      "id": "SQL_66",
      "title": "Total Sales Amount By Year",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_join",
        "sql_case_when",
        "sql_date_processing"
      ],
      "solution_summary": "The query calculates the total sales amount for each product by year by joining the Product and Sales tables. It uses a CASE statement to determine the number of days in each year that fall within the sales period, multiplying this by the average daily sales to get the total amount. The results are filtered to include only positive total amounts and are ordered by product ID and year.",
      "url": "https://leetcode.com/problems/total-sales-amount-by-year/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Total%20sales%20amount%20by%20year.sql"
    }
  },
  {
    "vector_content": "Table: Users\nTable: Orders\nitem_id is a foreign key to the Items table.\nbuyer_id and seller_id are foreign keys to the Users table.\nTable: Items\nWrite an SQL query to find for each user, whether the brand of the second item (by date) they sold is their favorite brand. If a user sold less than two items, report the answer for that user as no.\nIt is guaranteed that no seller sold more than one item on a day.\nThe query result format is in the following example:\nUsers table:\nOrders table:\nItems table:\nResult table:\nThe answer for the user with id 1 is no because they sold nothing.\nThe answer for the users with id 2 and 3 is yes because the brands of their second sold items are their favorite brands.\nThe answer for the user with id 4 is no because the brand of their second sold item is not their favorite brand.\nSolution\nwith t1 as(\nselect user_id,\ncase when favorite_brand = item_brand then \"yes\"\nelse \"no\"\nend as 2nd_item_fav_brand\nfrom users u left join\n(select o.item_id, seller_id, item_brand, rank() over(partition by seller_id order by order_date) as rk\nfrom orders o join items i\nusing (item_id)) a\non u.user_id = a.seller_id\nwhere a.rk = 2)\nselect u.user_id as seller_id, coalesce(2nd_item_fav_brand,\"no\") as 2nd_item_fav_brand\nfrom users u left join t1\nusing(user_id)",
    "metadata": {
      "id": "SQL_67",
      "title": "Market Analysis 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_hard",
        "sql_join",
        "sql_window_function",
        "sql_case_when",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to rank the items sold by each user based on the order date. It then checks if the brand of the second sold item matches the user's favorite brand using a CASE WHEN statement. Finally, it combines the results with the Users table to ensure that users who sold fewer than two items are reported as 'no'.",
      "url": "https://leetcode.com/problems/market-analysis-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Hard/Market%20Analysis%202.sql"
    }
  },
  {
    "vector_content": "Table: Friends\nname is the name of the friend.\nactivity is the name of the activity which the friend takes part in.\nTable: Activities\nname is the name of the activity.\nWrite an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants.\nThe query result format is in the following example:\nFriends table:\nActivities table:\nResult table:\nEating activity is performed by 3 friends, maximum number of participants, (Jonathan D. , Elvis Q. and Daniel A.)\nHorse Riding activity is performed by 1 friend, minimum number of participants, (Bob B.)\nSinging is performed by 2 friends (Victor J. and Jade W.)\nSolution\nwith t1 as(\nselect max(a.total) as total\nfrom(\nselect activity, count(*) as total\nfrom friends\ngroup by activity) a\nunion all\nselect min(b.total) as low\nfrom(\nselect activity, count(*) as total\nfrom friends\ngroup by activity) b),\nt2 as\n(\nselect activity, count(*) as total\nfrom friends\ngroup by activity\n)\nselect activity\nfrom t1 right join t2\non t1.total = t2.total\nwhere t1.total is null",
    "metadata": {
      "id": "SQL_68",
      "title": "Activity Participants",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_cte",
        "sql_join"
      ],
      "solution_summary": "The query first calculates the maximum and minimum number of participants for each activity using Common Table Expressions (CTEs). It then counts the total participants for each activity and performs a right join with the max and min counts. Finally, it filters out activities that match the maximum or minimum participant counts, returning only those with a participant count in between.",
      "url": "https://leetcode.com/problems/activity-participants/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Activity%20Participants.sql"
    }
  },
  {
    "vector_content": "In social network like Facebook or Twitter, people send friend requests and accept others' requests as well.\nWrite a query to find the the people who has most friends and the most friends number under the following rules:\nIt is guaranteed there is only 1 people having the most friends.\nThe friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.\nFor the sample data above, the result is:\nResult table:\nThe person with id '3' is a friend of people '1', '2' and '4', so he has 3 friends in total, which is the most number than any others.\nSolution\nselect requester_id as id, b.total as num\nfrom(\nselect requester_id, sum(one) as total\nfrom((\nselect requester_id, count(distinct accepter_id) as one\nfrom request_accepted\ngroup by requester_id)\nunion all\n(select accepter_id, count(distinct requester_id) as two\nfrom request_accepted\ngroup by accepter_id)) a\ngroup by requester_id\norder by total desc) b\nlimit 1",
    "metadata": {
      "id": "SQL_69",
      "title": "Friend Requests 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct",
        "sql_set_operations"
      ],
      "solution_summary": "The query calculates the total number of friends for each user by counting distinct accepter_ids for requester_ids and vice versa, using a union to combine the results. It then groups the results by requester_id and sums the counts to get the total number of friends for each user. Finally, it orders the results by the total number of friends in descending order and limits the output to the user with the highest count.",
      "url": "https://leetcode.com/problems/friend-requests-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Friend%20Requests%202.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to find employees who have the highest salary in each of the departments.\nFor the above tables, your SQL query should return the following rows (order of rows does not matter).\nExplanation:\nMax and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.\nSolution\nselect a.Department, a.Employee, a.Salary\nfrom(\nselect d.name as Department, e.name as Employee, Salary,\nrank() over(partition by d.name order by salary desc) as rk\nfrom employee e\njoin department d\non e.departmentid = d.id) a\nwhere a.rk=1",
    "metadata": {
      "id": "SQL_70",
      "title": "Department Highest Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_window_function"
      ],
      "solution_summary": "The query uses a common table expression to join the employee and department tables, selecting the department name, employee name, and salary. It applies the RANK() window function to assign a rank based on salary within each department, partitioned by department name. Finally, it filters the results to return only those employees with the highest salary in their respective departments.",
      "url": "https://leetcode.com/problems/department-highest-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Department%20Highest%20Salary.sql"
    }
  },
  {
    "vector_content": "A university uses 2 data tables, student and department, to store data about its students\nand the departments associated with each major.\nWrite a query to print the respective department name and number of students majoring in each\nSort your results by descending number of students; if two or more departments have the same number of students,\nthen sort those departments alphabetically by department name.\nThe student is described as follow:\nwhere student_id is the student's ID number, student_name is the student's name, gender is their gender, and dept_id is the department ID associated with their declared major.\nwhere dept_id is the department's ID number and dept_name is the department name.\nHere is an example input:\nstudent table:\ndepartment table:\nThe Output should be:\nSolution\nselect dept_name, count(s.dept_id) as student_number\nfrom department d\nleft join student s\non d.dept_id = s.dept_id\ngroup by d.dept_id\norder by count(s.dept_id) desc, dept_name",
    "metadata": {
      "id": "SQL_71",
      "title": "Count Student Number In Departments",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_sorting",
        "sql_join"
      ],
      "solution_summary": "The query joins the 'department' and 'student' tables on the department ID to associate students with their respective departments. It then counts the number of students in each department using aggregation and groups the results by department ID. Finally, the results are sorted in descending order by the number of students and alphabetically by department name for departments with the same student count.",
      "url": "https://leetcode.com/problems/count-student-number-in-departments/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Count%20student%20number%20in%20departments.sql"
    }
  },
  {
    "vector_content": "Table: Traffic\nWrite an SQL query that reports for every date within at most 90 days from today,\nthe number of users that logged in for the first time on that date. Assume today is 2019-06-30.\nThe query result format is in the following example:\nTraffic table:\nResult table:\nNote that we only care about dates with non zero user count.\nThe user with id 5 first logged in on 2019-03-01 so he's not counted on 2019-06-21.\nSolution\nwith t1 as\n(\nselect user_id, min(activity_date) as login_date\nfrom Traffic\nwhere activity = 'login'\ngroup by user_id\n)\nselect login_date, count(distinct user_id) as user_count\nfrom t1\nwhere login_date between '2019-04-01' and '2019-06-30'\ngroup by login_date",
    "metadata": {
      "id": "SQL_72",
      "title": "New Users Daily Count",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_cte",
        "sql_date_processing"
      ],
      "solution_summary": "The query first creates a Common Table Expression (CTE) to determine the first login date for each user by grouping the data by user_id and selecting the minimum activity_date. It then counts the distinct users who logged in on each date within the specified range of 2019-04-01 to 2019-06-30. This approach efficiently isolates new users by leveraging aggregation and grouping.",
      "url": "https://leetcode.com/problems/new-users-daily-count/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/New%20users%20daily%20count.sql"
    }
  },
  {
    "vector_content": "Table: Friendship\nTable: Likes\nWrite an SQL query to recommend pages to the user with user_id = 1 using the pages that your friends liked. It should not recommend pages you already liked.\nThe query result format is in the following example:\nFriendship table:\nLikes table:\nResult table:\nUser one is friend with users 2, 3, 4 and 6.\nSuggested pages are 23 from user 2, 24 from user 3, 56 from user 3 and 33 from user 6.\nPage 77 is suggested from both user 2 and user 3.\nPage 88 is not suggested because user 1 already likes it.\nSolution\nselect distinct page_id as recommended_page\nfrom likes\nwhere user_id =\nany(select user2_id as id\nfrom friendship\nwhere user1_id = 1 or user2_id = 1 and user2_id !=1\nunion all\nselect user1_id\nfrom friendship\nwhere user2_id = 1)\nand page_id != all(select page_id from likes where user_id = 1)",
    "metadata": {
      "id": "SQL_73",
      "title": "Page Recommnedations",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_subquery",
        "sql_distinct",
        "sql_set_operations"
      ],
      "solution_summary": "The query retrieves distinct page IDs that friends of user_id = 1 have liked, excluding pages that user_id = 1 has already liked. It uses subqueries to identify friends and their liked pages, ensuring that only new recommendations are suggested. The use of UNION ALL allows for combining results from both directions of friendship relationships.",
      "url": "https://leetcode.com/problems/page-recommnedations/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Page%20Recommnedations.sql"
    }
  },
  {
    "vector_content": "Table: Transactions\nTable: Chargebacks\nChargebacks contains basic information regarding incoming chargebacks from some transactions placed in Transactions table.\ntrans_id is a foreign key to the id column of Transactions table.\nEach chargeback corresponds to a transaction made previously even if they were not approved.\nWrite an SQL query to find for each month and country, the number of approved transactions and their total amount, the number of chargebacks and their total amount.\nNote: In your query, given the month and country, ignore rows with all zeros.\nThe query result format is in the following example:\nTransactions table:\nChargebacks table:\nResult table:\nSolution\nwith t1 as\n(select country, extract('month' from trans_date), state, count(*) as approved_count, sum(amount) as approved_amount\nfrom transactions\nwhere state = 'approved'\ngroup by 1, 2, 3),\nt2 as(\nselect t.country, extract('month' from c.trans_date), sum(amount) as chargeback_amount, count(*) as chargeback_count\nfrom chargebacks c left join transactions t\non trans_id = id\ngroup by t.country, extract('month' from c.trans_date)),\nt3 as(\nselect t2.date_part, t2.country, coalesce(approved_count,0) as approved_count, coalesce(approved_amount,0) as approved_amount, coalesce(chargeback_count,0) as chargeback_count, coalesce(chargeback_amount,0) as chargeback_amount\nfrom t2 left join t1\non t2.date_part = t1.date_part and t2.country = t1.country),\nt4 as(\nselect t1.date_part, t1.country, coalesce(approved_count,0) as approved_count, coalesce(approved_amount,0) as approved_amount, coalesce(chargeback_count,0) as chargeback_count, coalesce(chargeback_amount,0) as chargeback_amount\nfrom t2 right join t1\non t2.date_part = t1.date_part and t2.country = t1.country)\nselect *\nfrom t3\nunion\nselect *\nfrom t4",
    "metadata": {
      "id": "SQL_74",
      "title": "Monthly Transaction 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The query uses Common Table Expressions (CTEs) to first aggregate approved transactions and chargebacks by month and country. It then combines the results from both CTEs, ensuring that all relevant data is included, even if some counts or amounts are zero. The use of COALESCE ensures that null values are handled appropriately, providing a complete view of the transaction and chargeback data.",
      "url": "https://leetcode.com/problems/monthly-transaction-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Monthly%20Transaction%202.sql"
    }
  },
  {
    "vector_content": "Table: Views\nNote that equal author_id and viewer_id indicate the same person.\nWrite an SQL query to find all the people who viewed more than one article on the same date, sorted in ascending order by their id.\nThe query result format is in the following example:\nViews table:\nResult table:\nSolution\nselect distinct viewer_id as id#, count(distinct article_id) as total\nfrom views\ngroup by viewer_id, view_date\nhaving count(distinct article_id)>1\norder by 1",
    "metadata": {
      "id": "SQL_75",
      "title": "Article Views 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_sorting",
        "sql_distinct"
      ],
      "solution_summary": "The query groups the data by viewer_id and view_date, counting the distinct article_ids viewed on each date. It filters the results to include only those viewers who have viewed more than one article on the same date. Finally, it sorts the results in ascending order by viewer_id.",
      "url": "https://leetcode.com/problems/article-views-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Article%20Views%202.sql"
    }
  },
  {
    "vector_content": "Table: Movies\ntitle is the name of the movie.\nTable: Users\nTable: Movie_Rating\ncreated_at is the user's review date.\nWrite the following SQL query:\nFind the name of the user who has rated the greatest number of the movies.\nIn case of a tie, return lexicographically smaller user name.\nFind the movie name with the highest average rating in February 2020.\nIn case of a tie, return lexicographically smaller movie name.\nQuery is returned in 2 rows, the query result format is in the folowing example:\nMovies table:\nUsers table:\nMovie_Rating table:\nResult table:\nDaniel and Maria have rated 3 movies (\"Avengers\", \"Frozen 2\" and \"Joker\") but Daniel is smaller lexicographically.\nFrozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically.\nSolution\nselect name as results\nfrom(\n(select a.name\nfrom(\nselect name, count(*),\nrank() over(order by count(*) desc) as rk\nfrom movie_rating m\njoin users u\non m.user_id = u.user_id\ngroup by name, m.user_id\norder by rk, name) a\nlimit 1)\nunion\n(select title\nfrom(\nselect title, round(avg(rating),1) as rnd\nfrom movie_rating m\njoin movies u\non m.movie_id = u.movie_id\nwhere month(created_at) = 2\ngroup by title\norder by rnd desc, title) b\nlimit 1)) as d",
    "metadata": {
      "id": "SQL_76",
      "title": "Movie Rating",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_window_function",
        "sql_set_operations"
      ],
      "solution_summary": "The query first identifies the user who has rated the most movies by joining the Movie_Rating and Users tables, counting the ratings, and using a window function to rank them. It then finds the movie with the highest average rating in February 2020 by joining the Movie_Rating and Movies tables, calculating the average rating, and sorting the results. The final output combines these two results using a UNION, ensuring that ties are resolved lexicographically.",
      "url": "https://leetcode.com/problems/movie-rating/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Movie%20Rating.sql"
    }
  },
  {
    "vector_content": "operator is an enum that takes one of the values ('<', '>', '=')\nThe values of left_operand and right_operand are guaranteed to be in the Variables table.\nWrite an SQL query to evaluate the boolean expressions in Expressions table.\nThe query result format is in the following example.\nVariables table:\nExpressions table:\nResult table:\nSolution\nwith t1 as(\nselect e.left_operand, e.operator, e.right_operand, v.value as left_val, v_1.value as right_val\nfrom expressions e\njoin variables v\non v.name = e.left_operand\njoin variables v_1\non v_1.name = e.right_operand)\nselect t1.left_operand, t1.operator, t1.right_operand,\ncase when t1.operator = '<' then (select t1.left_val< t1.right_val)\nwhen t1.operator = '>' then (select t1.left_val > t1.right_val)\nwhen t1.operator = '=' then (select t1.left_val = t1.right_val)\nelse FALSE\nEND AS VALUE\nfrom t1",
    "metadata": {
      "id": "SQL_77",
      "title": "Evaluate Boolean Expressions",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_case_when",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to join the Expressions and Variables tables, retrieving the left and right operand values. It then evaluates the boolean expressions based on the specified operators using a CASE WHEN statement to determine the result for each expression. This approach is efficient as it consolidates the logic into a single query, leveraging joins and conditional logic effectively.",
      "url": "https://leetcode.com/problems/evaluate-boolean-expressions/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Evaluate%20Boolean%20Expressions.sql"
    }
  },
  {
    "vector_content": "Write a query to find the shortest distance between these points rounded to 2 decimals.\nThe shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be:\nNote: The longest distance among all the points are less than 10000.\nSolution\nselect round(a.shortest,2) as shortest\nfrom(\nselect sqrt(pow((p1.x-p2.x),2)+pow((p1.y-p2.y),2)) as shortest\nfrom point_2d p1\ncross join point_2d p2\nwhere p1.x!=p2.x or p1.y!=p2.y\norder by sqrt(pow((p1.x-p2.x),2)+pow((p1.y-p2.y),2))\nlimit 1) a",
    "metadata": {
      "id": "SQL_78",
      "title": "Shortest Distance In A Plane",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_subquery",
        "sql_sorting"
      ],
      "solution_summary": "The query calculates the shortest distance between all pairs of points in the 'point_2d' table using the Euclidean distance formula. It employs a cross join to generate all combinations of points, filtering out identical points. The results are ordered by distance, and the shortest distance is selected and rounded to two decimal places.",
      "url": "https://leetcode.com/problems/shortest-distance-in-a-plane/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Shortest%20distance%20in%20a%20plane.sql"
    }
  },
  {
    "vector_content": "Table: Queue\nThe person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table.\nThe maximum weight the elevator can hold is 1000.\nWrite an SQL query to find the person_name of the last person who will fit in the elevator without exceeding the weight limit. It is guaranteed that the person who is first in the queue can fit in the elevator.\nThe query result format is in the following example:\nQueue table\nResult table\nIn the example George Washington(id 5), John Adams(id 3) and Thomas Jefferson(id 6) will enter the elevator as their weight sum is 250 + 350 + 400 = 1000.\nThomas Jefferson(id 6) is the last person to fit in the elevator because he has the last turn in these three people.\nSolution\nWith t1 as\n(\nselect *,\nsum(weight) over(order by turn) as cum_weight\nfrom queue\norder by turn)\nselect t1.person_name\nfrom t1\nwhere turn = (select max(turn) from t1 where t1.cum_weight<=1000)",
    "metadata": {
      "id": "SQL_79",
      "title": "Last Person To Fit In The Elevator",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_cte",
        "sql_subquery"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to calculate the cumulative weight of individuals in the queue based on their turn. It then selects the person_name of the last individual whose cumulative weight does not exceed the elevator's weight limit of 1000. This approach efficiently identifies the last person to fit in the elevator by leveraging window functions and subqueries.",
      "url": "https://leetcode.com/problems/last-person-to-fit-in-the-elevator/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Last%20person%20to%20fit%20in%20the%20elevator.sql"
    }
  },
  {
    "vector_content": "Table: Sales\nWrite an SQL query to report the difference between number of apples and oranges sold each day.\nThe query result format is in the following example:\nSales table:\nResult table:\nDay 2020-05-01, 10 apples and 8 oranges were sold (Difference  10 - 8 = 2).\nDay 2020-05-02, 15 apples and 15 oranges were sold (Difference 15 - 15 = 0).\nDay 2020-05-03, 20 apples and 0 oranges were sold (Difference 20 - 0 = 20).\nDay 2020-05-04, 15 apples and 16 oranges were sold (Difference 15 - 16 = -1).\nSolution\nSelect sale_date, sold_num-sold as diff\nfrom\n((select *\nfrom sales\nwhere fruit = 'apples') a\njoin\n(select sale_date as sale, fruit, sold_num as sold\nfrom sales\nwhere fruit = 'oranges') b\non a.sale_date = b.sale)",
    "metadata": {
      "id": "SQL_80",
      "title": "Apples & Oranges",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_filter"
      ],
      "solution_summary": "The query uses a join to combine two subqueries: one for apples and one for oranges, based on the sale date. It calculates the difference between the number of apples and oranges sold for each day. This approach efficiently aggregates the sales data for comparison on a daily basis.",
      "url": "https://leetcode.com/problems/apples-&-oranges/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Apples%20%26%20Oranges.sql"
    }
  },
  {
    "vector_content": "Table: Customer\nproduct_key is a foreign key to Product table.\nTable: Product\nFor example:\nCustomer table:\nProduct table:\nResult table:\nThe customers who bought all the products (5 and 6) are customers with id 1 and 3.\nSolution\nselect customer_id\nfrom customer\ngroup by customer_id\nhaving count(distinct product_key) = (select COUNT(distinct product_key) from product)",
    "metadata": {
      "id": "SQL_81",
      "title": "Customers Who Bought All Products",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_distinct",
        "sql_subquery"
      ],
      "solution_summary": "The query selects customer IDs from the Customer table, grouping by customer_id. It uses the HAVING clause to filter groups where the count of distinct product_key matches the total count of distinct product_keys from the Product table. This ensures that only customers who have purchased all products are returned.",
      "url": "https://leetcode.com/problems/customers-who-bought-all-products/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Customers%20who%20bought%20all%20products.sql"
    }
  },
  {
    "vector_content": "Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria:\nHave the same TIV_2015 value as one or more other policyholders.\nAre not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).\nInput Format:\nwhere PID is the policyholder's policy ID, TIV_2015 is the total investment value in 2015, TIV_2016 is the total investment value in 2016, LAT is the latitude of the policy holder's city, and LON is the longitude of the policy holder's city.\nSample Input\nSample Output\nExplanation\nThe first record in the table, like the last record, meets both of the two criteria.\nThe TIV_2015 value '10' is as the same as the third and forth record, and its location unique.\nThe second record does not meet any of the two criteria. Its TIV_2015 is not like any other policyholders.\nAnd its location is the same with the third record, which makes the third record fail, too.\nSo, the result is the sum of TIV_2016 of the first and last record, which is 45.\nSolution\nselect sum(TIV_2016) TIV_2016\nfrom\n(select *, count(*) over (partition by TIV_2015) as c1, count(*) over (partition by LAT, LON) as c2\nfrom insurance ) t\nwhere c1 > 1 and c2 = 1;",
    "metadata": {
      "id": "SQL_82",
      "title": "Investments In 2016",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_window_function"
      ],
      "solution_summary": "The query calculates the sum of TIV_2016 for policyholders who have the same TIV_2015 value as others and are located in unique cities. It uses window functions to count occurrences of TIV_2015 and the (LAT, LON) pairs. The final selection filters for those with more than one occurrence of TIV_2015 and exactly one occurrence of their location, ensuring the criteria are met.",
      "url": "https://leetcode.com/problems/investments-in-2016/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Investments%20in%202016.sql"
    }
  },
  {
    "vector_content": "The column id is continuous increment.\nMary wants to change seats for the adjacent students.\nCan you write a SQL query to output the result for Mary?\nFor the sample input, the output is:\nSolution\nselect row_number() over (order by (if(id%2=1,id+1,id-1))) as id, student\nfrom seat",
    "metadata": {
      "id": "SQL_83",
      "title": "Exchange Seats",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_sorting"
      ],
      "solution_summary": "The query uses the ROW_NUMBER() window function to assign a unique sequential integer to each row based on the order of the adjusted seat IDs. It swaps the IDs of adjacent students by using an IF statement to determine the new order, effectively allowing Mary to change seats for the adjacent students. This approach is efficient as it directly manipulates the ordering without needing additional joins or subqueries.",
      "url": "https://leetcode.com/problems/exchange-seats/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Exchange%20Seats.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to find all numbers that appear at least three times consecutively.\nFor example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.\nSolution\nselect distinct a.num as ConsecutiveNums\nfrom(\nselect *,\nlag(num) over() as prev,\nlead(num) over() as next\nfrom logs) a\nwhere a.num = a.prev and a.num=a.next",
    "metadata": {
      "id": "SQL_84",
      "title": "Consecutive Numbers",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_distinct"
      ],
      "solution_summary": "The query uses window functions, specifically LAG and LEAD, to compare each number with its previous and next values. It identifies numbers that appear consecutively by checking if a number is equal to both its previous and next numbers. The DISTINCT keyword is used to ensure that each number is listed only once in the final result.",
      "url": "https://leetcode.com/problems/consecutive-numbers/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Consecutive%20Numbers.sql"
    }
  },
  {
    "vector_content": "Table: Customers\ncustomer_name is the name of the customer.\nTable: Orders\ncustomer_id is the id of the customer who bought the product \"product_name\".\nWrite an SQL query to report the customer_id and customer_name of customers who bought products \"A\", \"B\" but did not buy the product \"C\" since we want to recommend them buy this product.\nThe query result format is in the following example.\nCustomers table:\nOrders table:\nResult table:\nOnly the customer_id with id 3 bought the product A and B but not the product C.\nSolution\nwith t1 as\n(\nselect customer_id\nfrom orders\nwhere product_name = 'B' and\ncustomer_id in (select customer_id\nfrom orders\nwhere product_name = 'A'))\nSelect t1.customer_id, c.customer_name\nfrom t1 join customers c\non t1.customer_id = c.customer_id\nwhere t1.customer_id != all(select customer_id\nfrom orders\nwhere product_name = 'C')",
    "metadata": {
      "id": "SQL_85",
      "title": "Customers Who Bought A, B But Not C",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_subquery",
        "sql_cte",
        "sql_join"
      ],
      "solution_summary": "The query first creates a Common Table Expression (CTE) to select customer_ids of those who bought products 'A' and 'B'. It then joins this result with the Customers table to retrieve customer names. Finally, it filters out any customers who have purchased product 'C', ensuring that only those who bought 'A' and 'B' but not 'C' are included in the final result.",
      "url": "https://leetcode.com/problems/customers-who-bought-a,-b-but-not-c/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Customers%20who%20bought%20a%2C%20b%20but%20not%20c.sql"
    }
  },
  {
    "vector_content": "Table: NPV\nTable: Queries\nWrite an SQL query to find the npv of all each query of queries table.\nThe query result format is in the following example:\nNPV table:\nQueries table:\nResult table:\nThe npv value of (7, 2018) is not present in the NPV table, we consider it 0.\nThe npv values of all other queries can be found in the NPV table.\nSolution\nselect q.id, q.year, coalesce(n.npv,0) as npv\nfrom queries q\nleft join npv n\non q.id = n.id and q.year=n.year",
    "metadata": {
      "id": "SQL_86",
      "title": "Npv Queries",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_null_handling"
      ],
      "solution_summary": "The query performs a left join between the Queries table and the NPV table on the id and year columns. It uses the COALESCE function to return the NPV value from the NPV table or 0 if no matching record is found. This approach ensures that all queries are included in the result, even if their corresponding NPV values are absent.",
      "url": "https://leetcode.com/problems/npv-queries/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/NPV%20Queries.sql"
    }
  },
  {
    "vector_content": "Table: Transactions\nWrite an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.\nThe query result format is in the following example:\nTransactions table:\nResult table:\nSolution\nwith t1 as(\nselect DATE_FORMAT(trans_date,'%Y-%m') as month, country, count(state) as trans_count, sum(amount) as trans_total_amount\nfrom transactions\ngroup by country, month(trans_date)),\nt2 as (\nSelect DATE_FORMAT(trans_date,'%Y-%m') as month, country, count(state) as approved_count, sum(amount) as approved_total_amount\nfrom transactions\nwhere state = 'approved'\ngroup by country, month(trans_date))\nselect t1.month, t1.country, coalesce(t1.trans_count,0) as trans_count, coalesce(t2.approved_count,0) as approved_count, coalesce(t1.trans_total_amount,0) as trans_total_amount, coalesce(t2.approved_total_amount,0) as approved_total_amount\nfrom t1 left join t2\non t1.country = t2.country and t1.month = t2.month",
    "metadata": {
      "id": "SQL_87",
      "title": "Monthly Transactions 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The solution uses Common Table Expressions (CTEs) to first aggregate the total transactions and their amounts by month and country, and then to aggregate only the approved transactions. It performs a left join on these two CTEs to combine the results, ensuring that all transactions are included even if there are no approved ones. The use of COALESCE ensures that null values are replaced with zero for counts and amounts.",
      "url": "https://leetcode.com/problems/monthly-transactions-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Monthly%20Transactions%201.sql"
    }
  },
  {
    "vector_content": "id means user id; action has these kind of values: \"show\", \"answer\", \"skip\"; answer_id is not null when action column is \"answer\",\nwhile is null for \"show\" and \"skip\"; q_num is the numeral order of the question in current session.\nWrite a sql query to identify the question which has the highest answer rate.\nExample:\nInput:\nOutput:\nExplanation:\nquestion 285 has answer rate 1/1, while question 369 has 0/1 answer rate, so output 285.\nNote: The highest answer rate meaning is: answer number's ratio in show number in the same question.\nSolution\nwith t1 as(\nselect a.question_id, coalesce(b.answer/a.show_1,0) as rate\nfrom\n(select question_id, coalesce(count(*),0) as show_1\nfrom survey_log\nwhere action != 'answer'\ngroup by question_id) a\nleft join\n(select question_id, coalesce(count(*),0) as answer\nfrom survey_log\nwhere action = 'answer'\ngroup by question_id) b\non a.question_id = b.question_id)\nselect a.question_id as survey_log\nfrom\n( select t1.question_id,\nrank() over(order by rate desc) as rk\nfrom t1) a\nwhere a.rk = 1",
    "metadata": {
      "id": "SQL_88",
      "title": "Get Highest Answer Rate Question",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_window_function",
        "sql_cte"
      ],
      "solution_summary": "The query first aggregates the number of 'show' and 'answer' actions for each question using Common Table Expressions (CTEs). It then calculates the answer rate by dividing the number of answers by the number of shows for each question. Finally, it ranks the questions based on their answer rates and selects the question with the highest rank, ensuring that the question with the highest answer rate is returned.",
      "url": "https://leetcode.com/problems/get-highest-answer-rate-question/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Get%20highest%20answer%20rate%20question.sql"
    }
  },
  {
    "vector_content": "Table: Project\nemployee_id is a foreign key to Employee table.\nTable: Employee\nWrite an SQL query that reports the most experienced employees in each project.\nIn case of a tie, report all employees with the maximum number of experience years.\nThe query result format is in the following example:\nProject table:\nEmployee table:\nResult table:\nBoth employees with id 1 and 3 have the\nmost experience among the employees of the first project. For the second project, the employee with id 1 has the most experience.\nSolution\nwith t1 as(\nselect p.project_id, p.employee_id, e.experience_years,\nrank() over(partition by project_id order by experience_years desc) as rk\nfrom project p\njoin employee e\non p.employee_id = e.employee_id)\nselect t1.project_id, t1.employee_id\nfrom t1\nwhere t1.rk = 1",
    "metadata": {
      "id": "SQL_89",
      "title": "Project Employees 3",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_window_function",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to join the Project and Employee tables, selecting the project_id, employee_id, and experience_years. It then applies the RANK() window function to assign a rank to employees based on their experience years within each project. Finally, it filters the results to return only those employees with the highest rank, indicating they have the most experience in their respective projects.",
      "url": "https://leetcode.com/problems/project-employees-3/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Project%20Employees%203.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to get the nth highest salary from the Employee table.\nFor example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.\nSolution\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\nRETURN (\n# Write your MySQL query statement below.\nselect distinct a.salary\nfrom\n(select salary,\ndense_rank() over(order by salary desc) as rk\nfrom Employee) a\nwhere a.rk = N\n);\nEND",
    "metadata": {
      "id": "SQL_90",
      "title": "Nth Highest Salary",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_distinct"
      ],
      "solution_summary": "The query uses a subquery to calculate the distinct salaries from the Employee table and assigns a rank to each salary using the DENSE_RANK() window function, ordered by salary in descending order. It then filters the results to return the salary that corresponds to the specified rank (N). This approach efficiently handles ties in salaries and ensures that the nth highest salary is accurately retrieved.",
      "url": "https://leetcode.com/problems/nth-highest-salary/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Nth%20Highest%20salary.sql"
    }
  },
  {
    "vector_content": "Leaf: if the node is a leaf node.\nRoot: if the node is the root of the tree.\nInner: If the node is neither a leaf node nor a root node.\nExplanation\nNode '1' is root node, because its parent node is NULL and it has child node '2' and '3'.\nNode '2' is inner node, because it has parent node '1' and child node '4' and '5'.\nNode '3', '4' and '5' is Leaf node, because they have parent node and they don't have child node.\nAnd here is the image of the sample tree as below:\n1\n/   \\\n2       3\n/   \\\n4       5\nNote\nIf there is only one node on the tree, you only need to output its root attributes.\nSolution\nselect id,\ncase when p_id is null then 'Root'\nwhen id not in (select p_id from tree where p_id is not null group by p_id) then 'Leaf'\nelse 'Inner'\nfrom tree\norder by id",
    "metadata": {
      "id": "SQL_91",
      "title": "Tree Node",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_case_when",
        "sql_subquery",
        "sql_sorting"
      ],
      "solution_summary": "The query selects the id of each node and categorizes it as 'Root', 'Leaf', or 'Inner' using a CASE WHEN statement. It checks if the parent id (p_id) is NULL to identify the root, and uses a subquery to determine if the node has any children to classify it as a leaf. The results are then ordered by the node id.",
      "url": "https://leetcode.com/problems/tree-node/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Tree%20Node.sql"
    }
  },
  {
    "vector_content": "Write a SQL query to rank scores.\nIf there is a tie between two scores, both should have the same ranking.\nNote that after a tie, the next ranking number should be the next consecutive integer value.\nIn other words, there should be no \"holes\" between ranks.\nFor example, given the above Scores table, your query should generate the following report (order by highest score):\nyou can use an apostrophe before and after the keyword. For example `Rank`.\nSolution\nselect Score,\ndense_rank() over(order by score desc) as \"Rank\"\nfrom scores",
    "metadata": {
      "id": "SQL_92",
      "title": "Rank Scores",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function"
      ],
      "solution_summary": "The query uses the DENSE_RANK() window function to assign ranks to scores in descending order. This ensures that tied scores receive the same rank, and subsequent ranks are assigned without gaps. The approach is efficient as it directly computes the rank in a single pass over the data without requiring additional sorting or grouping operations.",
      "url": "https://leetcode.com/problems/rank-scores/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Rank%20scores.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.\nWrite an SQL query that reports for each player and date, how many games played so far by the player. That is, the total number of games played by the player until that date. Check the example for clarity.\nThe query result format is in the following example:\nActivity table:\nResult table:\nFor the player with id 1, 5 + 6 = 11 games played by 2016-05-02, and 5 + 6 + 1 = 12 games played by 2017-06-25.\nFor the player with id 3, 0 + 5 = 5 games played by 2018-07-03.\nNote that for each player we only care about the days when the player logged in.\nSolution\nselect player_id, event_date,\nsum(games_played) over(partition by player_id order by event_date) as games_played_so_far\nfrom activity\norder by 1,2",
    "metadata": {
      "id": "SQL_93",
      "title": "Game Play Analysis 3",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_sorting"
      ],
      "solution_summary": "The query calculates the cumulative sum of games played by each player up to each event date using a window function. It partitions the data by player_id and orders it by event_date to ensure the running total is calculated correctly. This approach efficiently provides the total games played for each player on the specific dates they logged in.",
      "url": "https://leetcode.com/problems/game-play-analysis-3/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Game%20Play%20Analysis%203.sql"
    }
  },
  {
    "vector_content": "Table: Sales\nproduct_id is a foreign key to Product table.\nNote that the price is per unit.\nTable: Product\nWrite an SQL query that selects the product id, year, quantity, and price for the first year of every product sold.\nThe query result format is in the following example:\nSales table:\nProduct table:\nResult table:\nSolution\nselect a.product_id, a.year as first_year, a.quantity, a.price\nfrom\n( select product_id, quantity, price, year,\nrank() over(partition by product_id order by year) as rk\nfrom sales\n) a\nwhere a.rk = 1",
    "metadata": {
      "id": "SQL_94",
      "title": "Product Sales Analysis 3",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function"
      ],
      "solution_summary": "The query uses a window function to rank the sales records for each product by year. It selects the product ID, year, quantity, and price for the first year of sales by filtering for records where the rank is 1. This approach efficiently identifies the earliest sales data for each product.",
      "url": "https://leetcode.com/problems/product-sales-analysis-3/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Product%20Sales%20Analysis%203.sql"
    }
  },
  {
    "vector_content": "Table: Delivery\nIf the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise it's called scheduled.\nThe first order of a customer is the order with the earliest order date that customer made. It is guaranteed that a customer has exactly one first order.\nWrite an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.\nThe query result format is in the following example:\nDelivery table:\nResult table:\nThe customer id 1 has a first order with delivery id 1 and it is scheduled.\nThe customer id 2 has a first order with delivery id 2 and it is immediate.\nThe customer id 3 has a first order with delivery id 5 and it is scheduled.\nThe customer id 4 has a first order with delivery id 7 and it is immediate.\nHence, half the customers have immediate first orders.\nSolution\nselect\nround(avg(case when order_date = customer_pref_delivery_date then 1 else 0 end)*100,2) as\nimmediate_percentage\nfrom\n(select *,\nrank() over(partition by customer_id order by order_date) as rk\nfrom delivery) a\nwhere a.rk=1",
    "metadata": {
      "id": "SQL_95",
      "title": "Immediate Food Delivery 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_case_when",
        "sql_aggregation"
      ],
      "solution_summary": "The query first ranks the orders of each customer by order date using a window function. It then filters to select only the first order for each customer. Finally, it calculates the percentage of these first orders that are immediate by comparing the order date with the preferred delivery date, rounding the result to two decimal places.",
      "url": "https://leetcode.com/problems/immediate-food-delivery-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Immediate%20Food%20Delivery%202.sql"
    }
  },
  {
    "vector_content": "Table: Points\nEach point is represented as a 2D Dimensional (x_value, y_value).\nWrite an SQL query to report of all possible rectangles which can be formed by any two points of the table.\nEach row in the result contains three columns (p1, p2, area) where:\np1 and p2 are the id of two opposite corners of a rectangle and p1 < p2.\nArea of this rectangle is represented by the column area.\nReport the query in descending order by area in case of tie in ascending order by p1 and p2.\nPoints table:\nResult table:\np1 should be less than p2 and area greater than 0.\np1 = 1 and p2 = 2, has an area equal to |2-4| * |8-7| = 2.\np1 = 2 and p2 = 3, has an area equal to |4-2| * |7-10| = 6.\np1 = 1 and p2 = 3 It's not possible because the rectangle has an area equal to 0.\nSolution\nselect p1.id as p1, p2.id as p2, abs(p1.x_value-p2.x_value)*abs(p1.y_value-p2.y_value) as area\nfrom points p1 cross join points p2\nwhere p1.x_value!=p2.x_value and p1.y_value!=p2.y_value and p1.id<p2.id\norder by area desc, p1, p2",
    "metadata": {
      "id": "SQL_96",
      "title": "Rectangles Area",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_sorting"
      ],
      "solution_summary": "The query uses a cross join to pair every point with every other point, calculating the area of the rectangle formed by the two points. It filters out pairs where the x or y coordinates are the same, ensuring a valid rectangle with a positive area. The results are then ordered by area in descending order, and by point IDs in ascending order for ties.",
      "url": "https://leetcode.com/problems/rectangles-area/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Rectangles%20Area.sql"
    }
  },
  {
    "vector_content": "Table: UserActivity\nA person with username performed a activity from startDate to endDate.\nWrite an SQL query to show the second most recent activity of each user.\nIf the user only has one activity, return that one.\nThe query result format is in the following example:\nUserActivity table:\nResult table:\nThe most recent activity of Alice is Travel from 2020-02-24 to 2020-02-28, before that she was dancing from 2020-02-21 to 2020-02-23.\nBob only has one record, we just take that one.\nSolution\nselect username, activity, startdate, enddate\nfrom\n(select *,\nrank() over(partition by username order by startdate desc) as rk,\ncount(username) over(partition by username) as cnt\nfrom useractivity) a\nwhere a.rk = 2 or cnt = 1",
    "metadata": {
      "id": "SQL_97",
      "title": "Get The Second Most Recent Activity",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_aggregation"
      ],
      "solution_summary": "The query uses a subquery to rank activities for each user based on their start date in descending order, allowing identification of the most recent and second most recent activities. It also counts the number of activities per user to handle cases where a user has only one activity. The final selection filters for the second most recent activity or returns the only activity if the user has just one.",
      "url": "https://leetcode.com/problems/get-the-second-most-recent-activity/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Get%20the%20second%20most%20recent%20activity.sql"
    }
  },
  {
    "vector_content": "Table: Customer\nvisited_on is the date on which the customer with ID (customer_id) have visited the restaurant.\namount is the total paid by a customer.\nYou are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day).\nWrite an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) .\nThe query result format is in the following example:\naverage_amount should be rounded to 2 decimal places, all dates are in the format ('YYYY-MM-DD').\nCustomer table:\nResult table:\n1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86\n2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120\n3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120\n4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86\nSolution\nselect visited_on, sum(amount) over(order by visited_on rows 6 preceding),\nround(avg(amount) over(order by visited_on rows 6 preceding),2)\nfrom\n(\nselect visited_on, sum(amount) as amount\nfrom customer\ngroup by visited_on\norder by visited_on\n) a\norder by visited_on offset 6 rows",
    "metadata": {
      "id": "SQL_98",
      "title": "Restaurant Growth",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_window_function"
      ],
      "solution_summary": "The query calculates the moving average of customer payments over a 7-day window by first aggregating the total amount paid per day. It then uses window functions to compute the sum and average of these amounts over the specified range of days. The final result is rounded to two decimal places and ordered by the visit date, ensuring that the moving average is calculated correctly for each day.",
      "url": "https://leetcode.com/problems/restaurant-growth/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Restaurant%20growth.sql"
    }
  },
  {
    "vector_content": "Table: Employees\nwork to his/her direct manager with manager_id\nThe head of the company is the employee with employee_id = 1.\nWrite an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company.\nThe indirect relation between managers will not exceed 3 managers as the company is small.\nThe query result format is in the following example:\nEmployees table:\nResult table:\nThe head of the company is the employee with employee_id 1.\nThe employees with employee_id 2 and 77 report their work directly to the head of the company.\nThe employee with employee_id 4 report his work indirectly to the head of the company 4 --> 2 --> 1.\nThe employee with employee_id 7 report his work indirectly to the head of the company 7 --> 4 --> 2 --> 1.\nThe employees with employee_id 3, 8 and 9 don't report their work to head of company directly or indirectly.\nSolution\nselect employee_id\nfrom employees\nwhere manager_id = 1 and employee_id != 1\nunion\nselect employee_id\nfrom employees\nwhere manager_id = any (select employee_id\nfrom employees\nwhere manager_id = 1 and employee_id != 1)\nunion\nselect employee_id\nfrom employees\nwhere manager_id = any (select employee_id\nfrom employees\nwhere manager_id = any (select employee_id\nfrom employees\nwhere manager_id = 1 and employee_id != 1))",
    "metadata": {
      "id": "SQL_99",
      "title": "All People Report To The Given Manager",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_subquery",
        "sql_set_operations"
      ],
      "solution_summary": "The query retrieves employee IDs of all employees who report directly or indirectly to the head of the company (employee_id = 1). It uses three UNION operations to combine results from three levels of reporting: direct reports, reports of direct reports, and reports of reports of direct reports. This approach efficiently captures all employees within three managerial levels under the head of the company.",
      "url": "https://leetcode.com/problems/all-people-report-to-the-given-manager/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/All%20people%20report%20to%20the%20given%20manager.sql"
    }
  },
  {
    "vector_content": "Table: Stocks\nIt is guaranteed that each 'Sell' operation for a stock has a corresponding 'Buy' operation in a previous day.\nWrite an SQL query to report the Capital gain/loss for each stock.\nThe capital gain/loss of a stock is total gain or loss after buying and selling the stock one or many times.\nThe query result format is in the following example:\nStocks table:\nResult table:\nLeetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$.\nHandbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$.\nCorona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each ('Buy' --> 'Sell')\noperation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$.\nSolution\nselect stock_name, (one-two) as capital_gain_loss\nfrom(\n(select stock_name, sum(price) as one\nfrom stocks\nwhere operation = 'Sell'\ngroup by stock_name) b\nleft join\n(select stock_name as name, sum(price) as two\nfrom stocks\nwhere operation = 'Buy'\ngroup by stock_name) c\non b.stock_name = c.name)\norder by capital_gain_loss desc",
    "metadata": {
      "id": "SQL_100",
      "title": "Capital Gain",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_sorting"
      ],
      "solution_summary": "The query calculates the capital gain/loss for each stock by summing the prices of 'Sell' operations and subtracting the sum of 'Buy' operations. It uses subqueries to aggregate the total prices for both operations, then joins the results on the stock name. Finally, it orders the results by capital gain/loss in descending order.",
      "url": "https://leetcode.com/problems/capital-gain/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Capital%20Gain.sql"
    }
  },
  {
    "vector_content": "Table: Actions\nTable: Removals\nWrite an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places.\nThe query result format is in the following example:\nActions table:\nRemovals table:\nResult table:\nThe percentage for 2019-07-04 is 50% because only one post of two spam reported posts was removed.\nThe percentage for 2019-07-02 is 100% because one post was reported as spam and it was removed.\nThe other days had no spam reports so the average is (50 + 100) / 2 = 75%\nNote that the output is only one number and that we do not care about the remove dates.\nSolution\nwith t1 as(\nselect a.action_date, (count(distinct r.post_id)+0.0)/(count(distinct a.post_id)+0.0) as result\nfrom (select action_date, post_id\nfrom actions\nwhere extra = 'spam' and action = 'report') a\nleft join\nremovals r\non a.post_id = r.post_id\ngroup by a.action_date)\nselect round(avg(t1.result)*100,2) as  average_daily_percent\nfrom t1",
    "metadata": {
      "id": "SQL_101",
      "title": "Reported Posts 2",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The query first creates a Common Table Expression (CTE) that selects the action date and calculates the ratio of distinct removed posts to distinct reported spam posts for each date. It uses a left join to combine the Actions and Removals tables based on post_id. Finally, it computes the average of these daily percentages, rounding the result to two decimal places.",
      "url": "https://leetcode.com/problems/reported-posts-2/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Reported%20Posts%202.sql"
    }
  },
  {
    "vector_content": "Table: Scores\nA competition is held between females team and males team.\nGender is 'F' if the player is in females team and 'M' if the player is in males team.\nWrite an SQL query to find the total score for each gender at each day.\nThe query result format is in the following example:\nScores table:\nResult table:\nFor females team:\nFirst day is 2019-12-30, Priyanka scored 17 points and the total score for the team is 17.\nSecond day is 2019-12-31, Priya scored 23 points and the total score for the team is 40.\nThird day is 2020-01-01, Aron scored 17 points and the total score for the team is 57.\nFourth day is 2020-01-07, Alice scored 23 points and the total score for the team is 80.\nFor males team:\nFirst day is 2019-12-18, Jose scored 2 points and the total score for the team is 2.\nSecond day is 2019-12-25, Khali scored 11 points and the total score for the team is 13.\nThird day is 2019-12-30, Slaman scored 13 points and the total score for the team is 26.\nFourth day is 2019-12-31, Joe scored 3 points and the total score for the team is 29.\nFifth day is 2020-01-07, Bajrang scored 7 points and the total score for the team is 36.\nSolution\nselect gender, day,\nsum(score_points) over(partition by gender order by day) as total\nfrom scores\ngroup by 1,2\norder by 1,2",
    "metadata": {
      "id": "SQL_102",
      "title": "Running Total For Different Genders",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_group_by",
        "sql_sorting"
      ],
      "solution_summary": "The query calculates the running total of scores for each gender by using the SUM() window function, partitioned by gender and ordered by day. It groups the results by gender and day to ensure that the total scores are calculated correctly for each day. The final output is sorted by gender and day to present the results in a clear chronological order.",
      "url": "https://leetcode.com/problems/running-total-for-different-genders/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Running%20total%20for%20different%20genders.sql"
    }
  },
  {
    "vector_content": "Table: Activity\nEach row is a record of a player who logged in and played a number of games (possibly 0)\nbefore logging out on some day using some device.\nWrite an SQL query that reports the fraction of players that logged in again\non the day after the day they first logged in, rounded to 2 decimal places.\nIn other words, you need to count the number of players that logged in for at least two consecutive\ndays starting from their first login date, then divide that number by the total number of players.\nThe query result format is in the following example:\nActivity table:\nResult table:\nOnly the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33\nSolution\nWith t as\n(select player_id,\nmin(event_date) over(partition by player_id) as min_event_date,\ncase when event_date- min(event_date) over(partition by player_id) = 1 then 1\nelse 0\nend as s\nfrom Activity)\nselect round(sum(t.s)/count(distinct t.player_id),2) as fraction\nfrom t",
    "metadata": {
      "id": "SQL_103",
      "title": "Game Play Analysis 4",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_case_when",
        "sql_cte",
        "sql_aggregation"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to calculate the minimum login date for each player and checks if they logged in the day after their first login using a CASE WHEN statement. It then aggregates the results to find the fraction of players who logged in again the next day, rounding the result to two decimal places. This approach efficiently counts the relevant players while ensuring accurate date comparisons.",
      "url": "https://leetcode.com/problems/game-play-analysis-4/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Game%20Play%20Analysis%204.sql"
    }
  },
  {
    "vector_content": "Please write a sql query to get the amount of each follower’s follower if he/she has one.\nFor example:\nshould output:\nExplaination:\nBoth B and D exist in the follower list, when as a followee, B's follower is C and D, and D's follower is E. A does not exist in follower list.\nNote:\nFollowee would not follow himself/herself in all cases.\nPlease display the result in follower's alphabet order.\nSolution\nselect followee as follower, count(distinct(follower)) as num\nfrom follow\nwhere followee = any(select follower from follow)\ngroup by followee\norder by followee",
    "metadata": {
      "id": "SQL_104",
      "title": "Second Degree Follower",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_subquery",
        "sql_sorting"
      ],
      "solution_summary": "The query counts the distinct followers for each followee who has at least one follower. It uses a subquery to filter followees that exist in the follower list. The results are grouped by followee and sorted in alphabetical order, ensuring a clear and organized output.",
      "url": "https://leetcode.com/problems/second-degree-follower/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Second%20degree%20follower.sql"
    }
  },
  {
    "vector_content": "Write an SQL query to find the salaries of the employees after applying taxes.\nThe tax rate is calculated for each company based on the following criteria:\n0% If the max salary of any employee in the company is less than 1000$.\n24% If the max salary of any employee in the company is in the range [1000, 10000] inclusive.\n49% If the max salary of any employee in the company is greater than 10000$.\nThe query result format is in the following example:\nSalaries table:\nResult table:\nFor company 1, Max salary is 21300. Employees in company 1 have taxes = 49%\nFor company 2, Max salary is 700. Employees in company 2 have taxes = 0%\nFor company 3, Max salary is 7777. Employees in company 3 have taxes = 24%\nThe salary after taxes = salary - (taxes percentage / 100) * salary\nFor example, Salary for Morninngcat (3, 15) after taxes = 7777 - 7777 * (24 / 100) = 7777 - 1866.48 = 5910.52, which is rounded to 5911.\nSolution\nwith t1 as (\nselect company_id, employee_id, employee_name, salary as sa, max(salary) over(partition by company_id) as maximum\nfrom salaries)\nselect company_id, employee_id, employee_name,\ncase when t1.maximum<1000 then t1.sa\nwhen t1.maximum between 1000 and 10000 then round(t1.sa*.76,0)\nelse round(t1.sa*.51,0)\nend as salary\nfrom t1",
    "metadata": {
      "id": "SQL_105",
      "title": "Calculate Salaries",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_case_when",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to calculate the maximum salary for each company. It then applies a CASE WHEN statement to determine the applicable tax rate based on the maximum salary and calculates the salary after taxes accordingly. This approach efficiently computes the required results in a single query by leveraging window functions and conditional logic.",
      "url": "https://leetcode.com/problems/calculate-salaries/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Calculate%20Salaries.sql"
    }
  },
  {
    "vector_content": "Write an SQL query to find the id and the name of active users.\nActive users are those who logged in to their accounts for 5 or more consecutive days.\nThe query result format is in the following example:\nAccounts table:\nLogins table:\nResult table:\nUser Winston with id = 1 logged in 2 times only in 2 different days, so, Winston is not an active user.\nUser Jonathan with id = 7 logged in 7 times in 6 different days, five of them were consecutive days, so, Jonathan is an active user.\nSolution\nwith t1 as (\nselect id,login_date,\nlead(login_date,4) over(partition by id order by login_date) date_5\nfrom (select distinct * from Logins) b\n)\nselect distinct a.id, a.name from t1\ninner join accounts a\non t1.id = a.id\nwhere datediff(t1.date_5,login_date) = 4\norder by id",
    "metadata": {
      "id": "SQL_106",
      "title": "Active Users",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_cte",
        "sql_join",
        "sql_date_processing"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to identify users who have logged in on consecutive days by utilizing the LEAD window function to check for logins 4 days ahead. It then joins this result with the Accounts table to retrieve the user details. The final filtering ensures that only users with 5 consecutive login days are selected.",
      "url": "https://leetcode.com/problems/active-users/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Active%20Users.sql"
    }
  },
  {
    "vector_content": "Table: Candidate\nTable: Vote\nCandidateId is the id appeared in Candidate table.\nWrite a sql to find the name of the winning candidate, the above example will return the winner B.\nNotes:\nYou may assume there is no tie, in other words there will be only one winning candidate\nSolution\nwith t1 as (\nselect *, rank() over(order by b.votes desc) as rk\nfrom candidate c\njoin\n(select candidateid, count(*) as votes\nfrom vote\ngroup by candidateid) b\non c.id = b.candidateid)\nselect t1.name\nfrom t1\nwhere t1.rk=1",
    "metadata": {
      "id": "SQL_107",
      "title": "Winning Candidate",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_aggregation",
        "sql_window_function",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to first join the Candidate and Vote tables, counting the votes for each candidate. It then applies a window function to rank the candidates based on their vote counts in descending order. Finally, it selects the name of the candidate with the highest rank, which corresponds to the winning candidate.",
      "url": "https://leetcode.com/problems/winning-candidate/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Winning%20Candidate.sql"
    }
  },
  {
    "vector_content": "Phone number will be in the form 'xxx-yyyyyyy' where xxx is the country code (3 characters) and yyyyyyy is the\nphone number (7 characters) where x and y are digits. Both can contain leading zeros.\nA telecommunications company wants to invest in new countries. The country intends to invest in the countries where the average call duration of the calls in this country is strictly greater than the global average call duration.\nWrite an SQL query to find the countries where this company can invest.\nThe query result format is in the following example.\nPerson table:\nCountry table:\nCalls table:\nResult table:\nThe average call duration for Peru is (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667\nThe average call duration for Israel is (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500\nThe average call duration for Morocco is (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000\nGlobal call duration average = (2 * (33 + 3 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000\nSince Peru is the only country where average call duration is greater than the global average, it's the only recommended country.\nSolution\nwith t1 as(\nselect caller_id as id, duration as total\nfrom\n(select caller_id, duration\nfrom calls\nunion all\nselect callee_id, duration\nfrom calls) a\n)\nselect name as country\nfrom\n(select distinct avg(total) over(partition by code) as avg_call, avg(total) over() as global_avg, c.name\nfrom\n((select *, coalesce(total,0) as duration, substring(phone_number from 1 for 3) as code\nfrom person right join t1\nusing (id)) b\njoin country c\non c.country_code = b.code)) d\nwhere avg_call > global_avg",
    "metadata": {
      "id": "SQL_108",
      "title": "Countries You Can Safely Invest In",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_join",
        "sql_window_function",
        "sql_cte",
        "sql_string_processing"
      ],
      "solution_summary": "The query calculates the average call duration for each country by joining the person, country, and calls tables. It uses a Common Table Expression (CTE) to aggregate call durations from both callers and callees. The average call duration for each country is compared against the global average to identify countries where investment is advisable.",
      "url": "https://leetcode.com/problems/countries-you-can-safely-invest-in/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Countries%20you%20can%20safely%20invest%20in.sql"
    }
  },
  {
    "vector_content": "Table: Teams\nTable: Matches\nEach row is a record of a finished match between two different teams.\nYou would like to compute the scores of all teams after all matches. Points are awarded as follows:\nA team receives three points if they win a match (Score strictly more goals than the opponent team).\nA team receives one point if they draw a match (Same number of goals as the opponent team).\nA team receives no points if they lose a match (Score less goals than the opponent team).\nThe query result format is in the following example:\nTeams table:\nMatches table:\nResult table:\nSolution\nwith t1 as(\nSelect c.host_id, c.host_name, c.host_points\nfrom(\nselect a.match_id, a.team_id as host_id, a.team_name as host_name, b.team_id as guest_id, b.team_name as guest_name, a.host_goals, a.guest_goals,\ncase\nwhen a.host_goals > a.guest_goals then 3\nwhen a.host_goals = a.guest_goals then 1\nelse 0\nend as host_points,\ncase\nwhen a.host_goals < a.guest_goals then 3\nwhen a.host_goals = a.guest_goals then 1\nelse 0\nend as guest_points\nfrom(\nselect *\nfrom matches m\njoin teams t\non t.team_id = m.host_team) a\njoin\n(select *\nfrom matches m\njoin teams t\non t.team_id = m.guest_team) b\non a.match_id = b.match_id) c\nunion all\nSelect d.guest_id, d.guest_name, d.guest_points\nfrom(\nselect a.match_id, a.team_id as host_id, a.team_name as host_name, b.team_id as guest_id, b.team_name as guest_name, a.host_goals, a.guest_goals,\ncase\nwhen a.host_goals > a.guest_goals then 3\nwhen a.host_goals = a.guest_goals then 1\nelse 0\nend as host_points,\ncase\nwhen a.host_goals < a.guest_goals then 3\nwhen a.host_goals = a.guest_goals then 1\nelse 0\nend as guest_points\nfrom(\nselect *\nfrom matches m\njoin teams t\non t.team_id = m.host_team) a\njoin\n(select *\nfrom matches m\njoin teams t\non t.team_id = m.guest_team) b\non a.match_id = b.match_id) d)\nSelect team_id, team_name, coalesce(total,0) as num_points\nfrom teams t2\nleft join(\nselect host_id, host_name, sum(host_points) as total\nfrom t1\ngroup by host_id, host_name) e\non t2.team_id = e.host_id\norder by num_points desc, team_id",
    "metadata": {
      "id": "SQL_109",
      "title": "Team Scores In Football Match",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_case_when",
        "sql_cte",
        "sql_aggregation"
      ],
      "solution_summary": "The solution uses Common Table Expressions (CTEs) to calculate points for both host and guest teams based on match results. It employs conditional logic with CASE WHEN statements to assign points based on the goals scored. Finally, it aggregates the total points for each team and sorts the results in descending order.",
      "url": "https://leetcode.com/problems/team-scores-in-football-match/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Team%20scores%20in%20football%20match.sql"
    }
  },
  {
    "vector_content": "Table: Users\nTable: Orders\nitem_id is a foreign key to the Items table.\nbuyer_id and seller_id are foreign keys to the Users table.\nTable: Items\nWrite an SQL query to find for each user, the join date and the number of orders they made as a buyer in 2019.\nThe query result format is in the following example:\nUsers table:\nOrders table:\nItems table:\nResult table:\nSolution\nselect user_id as buyer_id, join_date, coalesce(a.orders_in_2019,0)\nfrom users\nleft join\n(\nselect buyer_id, coalesce(count(*), 0) as orders_in_2019\nfrom orders o\njoin users u\non u.user_id = o.buyer_id\nwhere extract('year'from order_date) = 2019\ngroup by buyer_id) a\non users.user_id = a.buyer_id",
    "metadata": {
      "id": "SQL_110",
      "title": "Market Analysis 1",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_date_processing"
      ],
      "solution_summary": "The query retrieves each user's ID and join date while counting the number of orders they made as buyers in 2019. It uses a left join to combine the Users table with a subquery that aggregates order counts by buyer_id, filtered for the year 2019. The use of COALESCE ensures that users with no orders in 2019 are still included with a count of zero.",
      "url": "https://leetcode.com/problems/market-analysis-1/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Market%20Analysis%201.sql"
    }
  },
  {
    "vector_content": "Table: Enrollments\nWrite a SQL query to find the highest grade with its corresponding course for each student. In case of a tie, you should find the course with the smallest course_id. The output must be sorted by increasing student_id.\nThe query result format is in the following example:\nEnrollments table:\nResult table:\nSolution\nselect student_id, course_id, grade\nfrom(\nselect student_id, course_id, grade,\nrank() over(partition by student_id order by grade desc, course_id) as rk\nfrom enrollments) a\nwhere a.rk = 1",
    "metadata": {
      "id": "SQL_111",
      "title": "Highest Grade For Each Student",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_window_function",
        "sql_sorting"
      ],
      "solution_summary": "The query uses a window function to rank the grades of each student in descending order while also considering the course_id for tie-breaking. It then filters the results to only include the highest-ranked grade for each student. This approach efficiently retrieves the desired results while ensuring the output is sorted by student_id.",
      "url": "https://leetcode.com/problems/highest-grade-for-each-student/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Highest%20grade%20for%20each%20student.sql"
    }
  },
  {
    "vector_content": "Table: Books\nTable: Orders\nbook_id is a foreign key to the Books table.\nWrite an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23.\nThe query result format is in the following example:\nBooks table:\nOrders table:\nResult table:\nSolution\nselect b.book_id, name\nfrom\n(select *\nfrom books\nwhere available_from < '2019-05-23') b\nleft join\n(select *\nfrom orders\nwhere dispatch_date > '2018-06-23') a\non a.book_id = b.book_id\ngroup by b.book_id, name\nhaving coalesce(sum(quantity),0)<10",
    "metadata": {
      "id": "SQL_112",
      "title": "Unpopular Books",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_date_processing"
      ],
      "solution_summary": "The query selects books that have been available for more than a month and joins the Books and Orders tables. It filters orders to include only those dispatched in the last year. The results are grouped by book ID and name, and it uses a HAVING clause to find books that sold less than 10 copies.",
      "url": "https://leetcode.com/problems/unpopular-books/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Unpopular%20Books.sql"
    }
  },
  {
    "vector_content": "Table: Products\nWrite an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.\nThe query result format is in the following example:\nProducts table:\nResult table:\nSolution\nwith t1 as (\nselect a.product_id, new_price\nfrom(\nSelect product_id, max(change_date) as date\nfrom products\nwhere change_date<='2019-08-16'\ngroup by product_id) a\njoin products p\non a.product_id = p.product_id and a.date = p.change_date),\nt2 as (\nselect distinct product_id\nfrom products)\nselect t2.product_id, coalesce(new_price,10) as price\nfrom t2 left join t1\non t2.product_id = t1.product_id\norder by price desc",
    "metadata": {
      "id": "SQL_113",
      "title": "Product Price At A Given Date",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_join",
        "sql_aggregation",
        "sql_group_by",
        "sql_cte"
      ],
      "solution_summary": "The query uses a Common Table Expression (CTE) to first identify the most recent price change for each product before the specified date. It then selects distinct product IDs and performs a left join with the CTE to retrieve the corresponding prices, defaulting to 10 if no price change exists. This approach efficiently handles the requirement to find prices as of a specific date while ensuring all products are included in the result.",
      "url": "https://leetcode.com/problems/product-price-at-a-given-date/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Product%20Price%20at%20a%20given%20date.sql"
    }
  },
  {
    "vector_content": "Table: Events\nWrite an SQL query to find all active businesses.\nThe query result format is in the following example:\nEvents table:\nResult table:\nAverage for 'reviews', 'ads' and 'page views' are (7+3)/2=5, (11+7+6)/3=8, (3+12)/2=7.5 respectively.\nBusiness with id 1 has 7 'reviews' events (more than 5) and 11 'ads' events (more than 8) so it is an active business.\nSolution\nselect c.business_id\nfrom(\nselect *\nfrom events e\njoin\nwhere c.occurences>c.average\ngroup by c.business_id\nhaving count(*) > 1",
    "metadata": {
      "id": "SQL_114",
      "title": "Active Businesses",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_subquery"
      ],
      "solution_summary": "The query calculates the average occurrences of different event types by joining the Events table with a subquery that groups by event type. It then filters for businesses where the number of occurrences exceeds the calculated averages for reviews and ads. Finally, it groups the results by business_id and ensures that only businesses with more than one qualifying event are returned.",
      "url": "https://leetcode.com/problems/active-businesses/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Active%20Businesses.sql"
    }
  },
  {
    "vector_content": "Given the Employee table, write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return:\nNote:\nNo one would report to himself.\nSolution\nwith t1 as\n(\nselect managerid, count(name) as total\nfrom employee\ngroup by managerid\n)\nselect e.name\nfrom t1\njoin employee e\non t1.managerid = e.id\nwhere t1.total>=5",
    "metadata": {
      "id": "SQL_115",
      "title": "Managers With Atleast 5 Direct Reports",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_aggregation",
        "sql_group_by",
        "sql_join",
        "sql_cte"
      ],
      "solution_summary": "The query first creates a Common Table Expression (CTE) that counts the number of direct reports for each manager by grouping the Employee table by managerid. It then joins this CTE with the Employee table to retrieve the names of managers who have at least five direct reports. This approach efficiently isolates the relevant managers based on the count of their direct reports.",
      "url": "https://leetcode.com/problems/managers-with-atleast-5-direct-reports/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Managers%20with%20atleast%205%20direct%20reports.sql"
    }
  },
  {
    "vector_content": "Table: Logs\nThe query result format is in the following example:\nLogs table:\nResult table:\nFrom 1 to 3 is contained in the table.\nFrom 4 to 6 is missing in the table\nFrom 7 to 8 is contained in the table.\nNumber 9 is missing in the table.\nNumber 10 is contained in the table.\nSolution\nselect min(log_id) as start_id, max(log_id) as end_id\nfrom(\nselect log_id, log_id-row_number() over (order by log_id) as rk\nfrom logs) a\ngroup by rk",
    "metadata": {
      "id": "SQL_116",
      "title": "Find The Start And End Number Of Continuous Ranges",
      "category": "SQL",
      "taxonomy_skills": [
        "sql_medium",
        "sql_group_by",
        "sql_window_function"
      ],
      "solution_summary": "The query uses a window function to assign a row number to each log_id, then calculates a difference (rk) to identify continuous ranges. By grouping by this rk value, it allows for the aggregation of log_ids into start and end ranges, effectively identifying continuous sequences in the Logs table.",
      "url": "https://leetcode.com/problems/find-the-start-and-end-number-of-continuous-ranges/",
      "backup_url": "https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Find%20the%20start%20and%20end%20number%20of%20continuous%20ranges.sql"
    }
  }
]